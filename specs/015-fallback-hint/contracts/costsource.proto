syntax = "proto3";

package finfocus.v1;

option go_package = "github.com/rshade/finfocus-spec/sdk/go/proto;pbc";

import "google/protobuf/timestamp.proto";
import "google/protobuf/struct.proto";
import "finfocus/v1/focus.proto";

// CostSourceService provides gRPC interface for cost source plugins to implement.
// This service defines the contract for retrieving actual costs, projected costs,
// and pricing specifications from various cost data sources.
service CostSourceService {
  // Name returns the display name of the cost source plugin.
  rpc Name(NameRequest) returns (NameResponse);
  
  // Supports checks if the cost source supports pricing for a given resource type.
  rpc Supports(SupportsRequest) returns (SupportsResponse);
  
  // GetActualCost retrieves historical cost data for a specific resource.
  rpc GetActualCost(GetActualCostRequest) returns (GetActualCostResponse);
  
  // GetProjectedCost calculates projected cost information for a resource.
  rpc GetProjectedCost(GetProjectedCostRequest) returns (GetProjectedCostResponse);
  
  // GetPricingSpec returns detailed pricing specification for a resource type.
  rpc GetPricingSpec(GetPricingSpecRequest) returns (GetPricingSpecResponse);

  // EstimateCost returns an estimated monthly cost for a resource based on
  // its type and configuration attributes. This enables proactive cost
  // planning before resource deployment.
  //
  // The method is idempotent - identical inputs always produce identical
  // outputs (deterministic pricing). Response time should be <500ms for
  // standard resource types.
  //
  // Error cases:
  //   - InvalidArgument: Invalid resource_type format or missing required attributes
  //   - NotFound: Unsupported resource_type for this plugin
  //   - Unavailable: Pricing source temporarily unavailable
  rpc EstimateCost(EstimateCostRequest) returns (EstimateCostResponse);
}

// NameRequest is used for the Name RPC call (empty request).
message NameRequest {}

// NameResponse contains the plugin name information.
message NameResponse {
  // name is the display name of the cost source plugin (e.g., "kubecost", "cloudability")
  string name = 1;
}

// SupportsRequest contains the resource descriptor to check support for.
message SupportsRequest {
  // resource contains the resource descriptor to check support for
  ResourceDescriptor resource = 1;
}

// SupportsResponse indicates whether the cost source supports the requested resource.
message SupportsResponse {
  // supported indicates if the resource type is supported by this cost source
  bool supported = 1;
  // reason provides optional explanation if supported is false
  string reason = 2;
}

// GetActualCostRequest contains parameters for retrieving historical cost data.
message GetActualCostRequest {
  // resource_id is a flexible ID per plugin (e.g., "i-abc123", "namespace/default")
  string resource_id = 1;
  // start timestamp for the cost query period
  google.protobuf.Timestamp start = 2;
  // end timestamp for the cost query period
  google.protobuf.Timestamp end = 3;
  // tags provide optional extra filters for cost retrieval
  map<string, string> tags = 4;
}

// GetActualCostResponse contains the list of actual cost results.
message GetActualCostResponse {
  // results contains the actual cost data points for the requested period
  repeated ActualCostResult results = 1;
  // fallback_hint indicates whether the core should attempt to query other plugins
  FallbackHint fallback_hint = 2;
}

// GetProjectedCostRequest contains the resource descriptor for projected cost calculation.
message GetProjectedCostRequest {
  // resource contains the resource descriptor for cost projection
  ResourceDescriptor resource = 1;
}

// GetProjectedCostResponse contains projected cost information.
message GetProjectedCostResponse {
  // unit_price is the price per unit (aligned with PricingSpec.billing_mode)
  double unit_price = 1;
  // currency for the pricing (e.g., "USD")
  string currency = 2;
  // cost_per_month is a convenience field for a typical 30-day month
  double cost_per_month = 3;
  // billing_detail provides context (e.g., "on-demand", "kubecost-avg-daily")
  string billing_detail = 4;
}

// GetPricingSpecRequest contains the resource descriptor for pricing specification.
message GetPricingSpecRequest {
  // resource contains the resource descriptor for pricing specification
  ResourceDescriptor resource = 1;
}

// GetPricingSpecResponse contains the detailed pricing specification.
message GetPricingSpecResponse {
  // spec contains the complete pricing specification for the resource
  PricingSpec spec = 1;
}

// ResourceDescriptor describes a cloud resource for cost analysis.
message ResourceDescriptor {
  // provider identifies the cloud provider ("aws", "azure", "gcp", "kubernetes", "custom")
  string provider = 1;
  // resource_type specifies the resource type (e.g., "ec2", "s3", "k8s-namespace", "vm")
  string resource_type = 2;
  // sku is the provider SKU or instance size where applicable
  string sku = 3;
  // region specifies the deployment region (e.g., "us-east-1")
  string region = 4;
  // tags provide label/tag hints for resource identification (e.g., app=web)
  map<string, string> tags = 5;
}

// ActualCostResult represents a single cost data point.
message ActualCostResult {
  // timestamp indicates the point-in-time or bucket start for this cost data
  google.protobuf.Timestamp timestamp = 1;
  // cost is the total cost in the specified currency for the period/bucket
  double cost = 2;
  // usage_amount is the optional usage amount aligned with BillingMode
  double usage_amount = 3;
  // usage_unit specifies the unit of usage (e.g., "hour", "GB", "request")
  string usage_unit = 4;
  // source identifies the data source (e.g., "kubecost", "flexera")
  string source = 5;
  // focus_record provides the cost data in FOCUS 1.2 format.
  // This field is optional and will eventually replace the legacy fields.
  FocusCostRecord focus_record = 6;
}

// UsageMetricHint provides guidance on usage metrics for cost calculation.
message UsageMetricHint {
  // metric specifies the usage metric name (e.g., "vcpu_hours", "storage_gb", "requests")
  string metric = 1;
  // unit specifies the metric unit (e.g., "hour", "GB", "count")
  string unit = 2;
}

// PricingSpec provides detailed pricing information for a specific resource type.
message PricingSpec {
  // provider identifies the cloud provider for this pricing specification
  string provider = 1;
  // resource_type specifies the type of resource being priced
  string resource_type = 2;
  // sku is the specific SKU or instance type identifier
  string sku = 3;
  // region specifies the geographic region for pricing
  string region = 4;
  // billing_mode defines how the resource is billed 
  // (e.g., "per_hour", "per_gb_month", "per_request", "flat", "per_day", "per_cpu_hour")
  string billing_mode = 5;
  // rate_per_unit is the price per billing unit
  double rate_per_unit = 6;
  // currency specifies the pricing currency (e.g., "USD")
  string currency = 7;
  // description provides human-readable description of the pricing
  string description = 8;
  // metric_hints provide guidance on relevant usage metrics for cost calculation
  repeated UsageMetricHint metric_hints = 9;
  // plugin_metadata contains plugin-specific extra metadata (keys are not guaranteed to be stable)
  map<string, string> plugin_metadata = 10;
  // source identifies where the pricing model originated
  // (e.g., "aws", "gcp", "azure", "kubecost", "flexera", "cloudability", "spec")
  string source = 11;
  // unit specifies the unit of measurement for rate_per_unit
  // (e.g., "hour", "GB-month", "request", "unknown")
  string unit = 12;
  // assumptions contains human-readable strings explaining pricing derivation
  // and any constraints or conditions applied to the pricing calculation
  repeated string assumptions = 13;
  // pricing_tiers contains tiered pricing breakdown for volume-based billing
  // When billing_mode is "tiered", this array contains the pricing tiers
  repeated PricingTier pricing_tiers = 14;
}

// PricingTier represents one tier in a tiered pricing model.
// Used for volume-based pricing where rates decrease at higher usage levels.
message PricingTier {
  // min_quantity is the lower bound of this tier (inclusive)
  double min_quantity = 1;
  // max_quantity is the upper bound of this tier (exclusive, 0 means unlimited)
  double max_quantity = 2;
  // rate_per_unit is the price per unit within this tier
  double rate_per_unit = 3;
  // description provides human-readable explanation of this tier
  string description = 4;
}

// FallbackHint indicates whether the core system should attempt to query
// other plugins for the requested resource.
enum FallbackHint {
  // Default behavior (treated as FALLBACK_HINT_NONE).
  // The plugin either found data or is the definitive source.
  FALLBACK_HINT_UNSPECIFIED = 0;

  // Plugin has data or is authoritative; do not attempt fallback.
  FALLBACK_HINT_NONE = 1;

  // Plugin has no data and recommends checking other plugins.
  // Core should try fallback plugins if available.
  FALLBACK_HINT_RECOMMENDED = 2;

  // Plugin cannot handle this request (e.g. unsupported resource type).
  // Core must try fallback plugins or fail.
  FALLBACK_HINT_REQUIRED = 3;
}

// ErrorCategory defines the category of plugin errors.
enum ErrorCategory {
  ERROR_CATEGORY_UNSPECIFIED = 0;
  ERROR_CATEGORY_TRANSIENT = 1;    // Temporary failure that may succeed on retry
  ERROR_CATEGORY_PERMANENT = 2;    // Failure that will not succeed on retry without changes
  ERROR_CATEGORY_CONFIGURATION = 3; // Error due to invalid configuration or setup
}

// ErrorCode defines standard error codes for plugin operations.
enum ErrorCode {
  ERROR_CODE_UNSPECIFIED = 0;
  
  // Transient error codes
  ERROR_CODE_NETWORK_TIMEOUT = 1;      // Network timeout occurred
  ERROR_CODE_SERVICE_UNAVAILABLE = 2;  // Service temporarily unavailable
  ERROR_CODE_RATE_LIMITED = 3;         // Request was rate limited
  ERROR_CODE_TEMPORARY_FAILURE = 4;    // Temporary failure occurred
  ERROR_CODE_CIRCUIT_OPEN = 5;         // Circuit breaker is open
  
  // Permanent error codes
  ERROR_CODE_INVALID_RESOURCE = 6;     // Invalid resource specification
  ERROR_CODE_RESOURCE_NOT_FOUND = 7;   // Requested resource was not found
  ERROR_CODE_INVALID_TIME_RANGE = 8;   // Invalid time range parameters
  ERROR_CODE_UNSUPPORTED_REGION = 9;   // Region is not supported
  ERROR_CODE_PERMISSION_DENIED = 10;   // Access is denied
  ERROR_CODE_DATA_CORRUPTION = 11;     // Data corruption was detected
  
  // Configuration error codes
  ERROR_CODE_INVALID_CREDENTIALS = 12; // Authentication credentials are invalid
  ERROR_CODE_MISSING_API_KEY = 13;     // API key is missing
  ERROR_CODE_INVALID_ENDPOINT = 14;    // Endpoint configuration is invalid
  ERROR_CODE_INVALID_PROVIDER = 15;    // Provider specification is invalid
  ERROR_CODE_PLUGIN_NOT_CONFIGURED = 16; // Plugin is not properly configured
}

// ErrorDetail provides detailed information about an error.
message ErrorDetail {
  // code is the specific error code
  ErrorCode code = 1;
  // category is the error category (transient, permanent, configuration)
  ErrorCategory category = 2;
  // message is the human-readable error message
  string message = 3;
  // details contains structured error details
  map<string, string> details = 4;
  // retry_after_seconds suggests when to retry (for transient errors)
  optional int32 retry_after_seconds = 5;
  // timestamp when the error occurred
  google.protobuf.Timestamp timestamp = 6;
}

// ObservabilityService provides telemetry, health checks, and monitoring capabilities
// for cost source plugins. This service enables monitoring, debugging, and performance
// optimization of plugin implementations.
service ObservabilityService {
  // HealthCheck returns the current health status of the plugin.
  rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);
  
  // GetMetrics returns current metrics for monitoring plugin performance.
  rpc GetMetrics(GetMetricsRequest) returns (GetMetricsResponse);
  
  // GetServiceLevelIndicators returns current SLI measurements.
  rpc GetServiceLevelIndicators(GetServiceLevelIndicatorsRequest) returns (GetServiceLevelIndicatorsResponse);
}

// HealthCheckRequest is used for the HealthCheck RPC call.
message HealthCheckRequest {
  // service_name optionally specifies which service to check (empty for overall health)
  string service_name = 1;
}

// HealthCheckResponse contains the health status of the plugin.
message HealthCheckResponse {
  // Status represents the health check status
  enum Status {
    STATUS_UNSPECIFIED = 0;
    STATUS_SERVING = 1;
    STATUS_NOT_SERVING = 2;
    STATUS_SERVICE_UNKNOWN = 3;
  }
  
  // status indicates the current health status
  Status status = 1;
  // message provides optional details about the health status
  string message = 2;
  // last_check_time indicates when this status was last updated
  google.protobuf.Timestamp last_check_time = 3;
}

// GetMetricsRequest contains parameters for retrieving plugin metrics.
message GetMetricsRequest {
  // metric_names optionally filters which metrics to return (empty for all)
  repeated string metric_names = 1;
  // format specifies the output format (e.g., "prometheus", "json")
  string format = 2;
}

// GetMetricsResponse contains the plugin metrics.
message GetMetricsResponse {
  // metrics contains the collected metrics data
  repeated Metric metrics = 1;
  // timestamp indicates when these metrics were collected
  google.protobuf.Timestamp timestamp = 2;
  // format indicates the format of the metrics data
  string format = 3;
}

// Metric represents a single monitoring metric.
message Metric {
  // name is the metric name (e.g., "request_latency_seconds", "requests_total")
  string name = 1;
  // help provides a description of what the metric measures
  string help = 2;
  // type specifies the metric type (counter, gauge, histogram, summary)
  MetricType type = 3;
  // samples contains the metric data points
  repeated MetricSample samples = 4;
}

// MetricType represents the type of metric being reported.
enum MetricType {
  METRIC_TYPE_UNSPECIFIED = 0;
  METRIC_TYPE_COUNTER = 1;
  METRIC_TYPE_GAUGE = 2;
  METRIC_TYPE_HISTOGRAM = 3;
  METRIC_TYPE_SUMMARY = 4;
}

// MetricSample represents a single metric measurement.
message MetricSample {
  // labels contains key-value pairs for metric dimensions
  map<string, string> labels = 1;
  // value is the numeric value of this metric sample
  double value = 2;
  // timestamp indicates when this sample was recorded
  google.protobuf.Timestamp timestamp = 3;
}

// GetServiceLevelIndicatorsRequest contains parameters for retrieving Service Level Indicators.
message GetServiceLevelIndicatorsRequest {
  // time_range optionally specifies the time range for SLI calculation
  TimeRange time_range = 1;
  // sli_names optionally filters which SLIs to return (empty for all)
  repeated string sli_names = 2;
}

// GetServiceLevelIndicatorsResponse contains the current Service Level Indicators.
message GetServiceLevelIndicatorsResponse {
  // slis contains the current SLI measurements
  repeated ServiceLevelIndicator slis = 1;
  // measurement_time indicates when these SLIs were measured
  google.protobuf.Timestamp measurement_time = 2;
}

// ServiceLevelIndicator represents a measurable aspect of service quality.
message ServiceLevelIndicator {
  // name is the SLI name (e.g., "availability", "latency_p99", "error_rate")
  string name = 1;
  // description explains what this SLI measures
  string description = 2;
  // value is the current SLI value (e.g., 0.995 for 99.5% availability)
  double value = 3;
  // unit specifies the unit of measurement (e.g., "percentage", "seconds", "ratio")
  string unit = 4;
  // target_value is the target/goal value for this SLI
  double target_value = 5;
  // status indicates if the SLI is meeting its target
  SLIStatus status = 6;
}

// SLIStatus represents whether an SLI is meeting its target.
enum SLIStatus {
  SLI_STATUS_UNSPECIFIED = 0;
  SLI_STATUS_MEETING_TARGET = 1;
  SLI_STATUS_WARNING = 2;
  SLI_STATUS_CRITICAL = 3;
}

// TimeRange represents a time period for metrics and SLI calculations.
message TimeRange {
  // start timestamp for the time range
  google.protobuf.Timestamp start = 1;
  // end timestamp for the time range  
  google.protobuf.Timestamp end = 2;
}

// TelemetryMetadata provides observability context for RPC responses.
// This can be embedded in existing response messages to add telemetry capabilities.
message TelemetryMetadata {
  // trace_id is the distributed trace identifier for request correlation
  string trace_id = 1;
  // span_id is the current span identifier within the trace
  string span_id = 2;
  // request_id is a unique identifier for this specific request
  string request_id = 3;
  // processing_time_ms indicates how long the request took to process
  int64 processing_time_ms = 4;
  // data_source indicates the backend system that provided the data
  string data_source = 5;
  // cache_hit indicates if the response came from cache
  bool cache_hit = 6;
  // quality_score optionally indicates the data quality/confidence (0.0-1.0)
  double quality_score = 7;
}

// LogEntry represents a structured log entry for standardized logging.
message LogEntry {
  // timestamp when the log entry was created
  google.protobuf.Timestamp timestamp = 1;
  // level indicates the log level (e.g., "DEBUG", "INFO", "WARN", "ERROR")
  string level = 2;
  // message is the log message content
  string message = 3;
  // component identifies the plugin component that generated the log
  string component = 4;
  // trace_id for correlating logs with distributed traces
  string trace_id = 5;
  // span_id for correlating logs with specific spans
  string span_id = 6;
  // fields contains structured log fields as key-value pairs
  map<string, string> fields = 7;
  // error_details provides additional context for error logs
  ErrorDetails error_details = 8;
}

// ErrorDetails provides structured error information for logging and debugging.
message ErrorDetails {
  // error_code is a machine-readable error identifier
  string error_code = 1;
  // error_category classifies the type of error (e.g., "network", "auth", "data")
  string error_category = 2;
  // stack_trace provides debugging information (should be sanitized in production)
  string stack_trace = 3;
  // retry_after_seconds suggests when the client should retry (for transient errors)
  int32 retry_after_seconds = 4;
  // correlation_id helps correlate related errors across services
  string correlation_id = 5;
}

// EstimateCostRequest represents a request to estimate the cost of a Pulumi
// resource before deployment. This enables "what-if" cost analysis for
// configuration comparison and budget planning.
message EstimateCostRequest {
  // The full type name of the Pulumi resource to estimate cost for.
  // Must follow the format: "provider:module/resource:Type"
  //
  // Examples:
  //   - "aws:ec2/instance:Instance"
  //   - "azure:compute/virtualMachine:VirtualMachine"
  //   - "gcp:compute/instance:Instance"
  //
  // The resource_type must be supported by the plugin (check via Supports RPC).
  // Invalid formats will return InvalidArgument error.
  string resource_type = 1;

  // A structured representation of the resource's input properties.
  // This mirrors the structure of a Pulumi resource declaration.
  //
  // The attributes field may be null or missing, which is treated as an
  // empty struct. The plugin determines which attributes are required for
  // cost estimation based on its pricing model.
  //
  // Examples:
  //   AWS: {"instanceType": "t3.micro", "region": "us-east-1"}
  //   Azure: {"vmSize": "Standard_B1s", "location": "eastus"}
  //   GCP: {"machineType": "e2-micro", "zone": "us-central1-a"}
  google.protobuf.Struct attributes = 2;
}

// EstimateCostResponse contains the estimated monthly cost for a resource
// based on the provided configuration.
//
// Future versions may add optional breakdown fields (e.g., compute vs storage)
// while maintaining backward compatibility through optional fields.
message EstimateCostResponse {
  // The currency of the cost, as an ISO 4217 currency code.
  // Typically "USD" but depends on the plugin's pricing source.
  string currency = 1;

  // The estimated monthly cost for the resource.
  // Must be non-negative. Zero is valid for free-tier resources.
  // Monthly cost assumes 730 hours/month for hourly-billed resources.
  double cost_monthly = 2;
}
