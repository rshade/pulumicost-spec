// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file finfocus/v1/costsource.proto (package finfocus.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Struct, Timestamp } from "@bufbuild/protobuf";
import { FieldSupportStatus, GrowthType, PluginCapability, RecommendationReason } from "./enums_pb.js";
import { FocusCostRecord } from "./focus_pb.js";

/**
 * MetricKind represents the type of sustainability/impact metric supported by a plugin.
 *
 * @generated from enum finfocus.v1.MetricKind
 */
export enum MetricKind {
  /**
   * @generated from enum value: METRIC_KIND_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Carbon Footprint in grams of CO2 equivalent (gCO2e)
   *
   * @generated from enum value: METRIC_KIND_CARBON_FOOTPRINT = 1;
   */
  CARBON_FOOTPRINT = 1,

  /**
   * Electrical Energy Consumption in kilowatt-hours (kWh)
   *
   * @generated from enum value: METRIC_KIND_ENERGY_CONSUMPTION = 2;
   */
  ENERGY_CONSUMPTION = 2,

  /**
   * Water Usage in liters (L)
   *
   * @generated from enum value: METRIC_KIND_WATER_USAGE = 3;
   */
  WATER_USAGE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(MetricKind)
proto3.util.setEnumType(MetricKind, "finfocus.v1.MetricKind", [
  { no: 0, name: "METRIC_KIND_UNSPECIFIED" },
  { no: 1, name: "METRIC_KIND_CARBON_FOOTPRINT" },
  { no: 2, name: "METRIC_KIND_ENERGY_CONSUMPTION" },
  { no: 3, name: "METRIC_KIND_WATER_USAGE" },
]);

/**
 * FallbackHint indicates whether the core system should attempt to query
 * other plugins for the requested resource.
 *
 * @generated from enum finfocus.v1.FallbackHint
 */
export enum FallbackHint {
  /**
   * Default behavior (treated as FALLBACK_HINT_NONE).
   * The plugin either found data or is the definitive source.
   *
   * @generated from enum value: FALLBACK_HINT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Plugin has data or is authoritative; do not attempt fallback.
   *
   * @generated from enum value: FALLBACK_HINT_NONE = 1;
   */
  NONE = 1,

  /**
   * Plugin has no data and recommends checking other plugins.
   * Core should try fallback plugins if available.
   *
   * @generated from enum value: FALLBACK_HINT_RECOMMENDED = 2;
   */
  RECOMMENDED = 2,

  /**
   * Plugin cannot handle this request (e.g. unsupported resource type).
   * Core must try fallback plugins or fail.
   *
   * @generated from enum value: FALLBACK_HINT_REQUIRED = 3;
   */
  REQUIRED = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(FallbackHint)
proto3.util.setEnumType(FallbackHint, "finfocus.v1.FallbackHint", [
  { no: 0, name: "FALLBACK_HINT_UNSPECIFIED" },
  { no: 1, name: "FALLBACK_HINT_NONE" },
  { no: 2, name: "FALLBACK_HINT_RECOMMENDED" },
  { no: 3, name: "FALLBACK_HINT_REQUIRED" },
]);

/**
 * ErrorCategory defines the category of plugin errors.
 *
 * @generated from enum finfocus.v1.ErrorCategory
 */
export enum ErrorCategory {
  /**
   * @generated from enum value: ERROR_CATEGORY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Temporary failure that may succeed on retry
   *
   * @generated from enum value: ERROR_CATEGORY_TRANSIENT = 1;
   */
  TRANSIENT = 1,

  /**
   * Failure that will not succeed on retry without changes
   *
   * @generated from enum value: ERROR_CATEGORY_PERMANENT = 2;
   */
  PERMANENT = 2,

  /**
   * Error due to invalid configuration or setup
   *
   * @generated from enum value: ERROR_CATEGORY_CONFIGURATION = 3;
   */
  CONFIGURATION = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(ErrorCategory)
proto3.util.setEnumType(ErrorCategory, "finfocus.v1.ErrorCategory", [
  { no: 0, name: "ERROR_CATEGORY_UNSPECIFIED" },
  { no: 1, name: "ERROR_CATEGORY_TRANSIENT" },
  { no: 2, name: "ERROR_CATEGORY_PERMANENT" },
  { no: 3, name: "ERROR_CATEGORY_CONFIGURATION" },
]);

/**
 * ErrorCode defines standard error codes for plugin operations.
 *
 * @generated from enum finfocus.v1.ErrorCode
 */
export enum ErrorCode {
  /**
   * @generated from enum value: ERROR_CODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Transient error codes
   *
   * Network timeout occurred
   *
   * @generated from enum value: ERROR_CODE_NETWORK_TIMEOUT = 1;
   */
  NETWORK_TIMEOUT = 1,

  /**
   * Service temporarily unavailable
   *
   * @generated from enum value: ERROR_CODE_SERVICE_UNAVAILABLE = 2;
   */
  SERVICE_UNAVAILABLE = 2,

  /**
   * Request was rate limited
   *
   * @generated from enum value: ERROR_CODE_RATE_LIMITED = 3;
   */
  RATE_LIMITED = 3,

  /**
   * Temporary failure occurred
   *
   * @generated from enum value: ERROR_CODE_TEMPORARY_FAILURE = 4;
   */
  TEMPORARY_FAILURE = 4,

  /**
   * Circuit breaker is open
   *
   * @generated from enum value: ERROR_CODE_CIRCUIT_OPEN = 5;
   */
  CIRCUIT_OPEN = 5,

  /**
   * Permanent error codes
   *
   * Invalid resource specification
   *
   * @generated from enum value: ERROR_CODE_INVALID_RESOURCE = 6;
   */
  INVALID_RESOURCE = 6,

  /**
   * Requested resource was not found
   *
   * @generated from enum value: ERROR_CODE_RESOURCE_NOT_FOUND = 7;
   */
  RESOURCE_NOT_FOUND = 7,

  /**
   * Invalid time range parameters
   *
   * @generated from enum value: ERROR_CODE_INVALID_TIME_RANGE = 8;
   */
  INVALID_TIME_RANGE = 8,

  /**
   * Region is not supported
   *
   * @generated from enum value: ERROR_CODE_UNSUPPORTED_REGION = 9;
   */
  UNSUPPORTED_REGION = 9,

  /**
   * Access is denied
   *
   * @generated from enum value: ERROR_CODE_PERMISSION_DENIED = 10;
   */
  PERMISSION_DENIED = 10,

  /**
   * Data corruption was detected
   *
   * @generated from enum value: ERROR_CODE_DATA_CORRUPTION = 11;
   */
  DATA_CORRUPTION = 11,

  /**
   * Configuration error codes
   *
   * Authentication credentials are invalid
   *
   * @generated from enum value: ERROR_CODE_INVALID_CREDENTIALS = 12;
   */
  INVALID_CREDENTIALS = 12,

  /**
   * API key is missing
   *
   * @generated from enum value: ERROR_CODE_MISSING_API_KEY = 13;
   */
  MISSING_API_KEY = 13,

  /**
   * Endpoint configuration is invalid
   *
   * @generated from enum value: ERROR_CODE_INVALID_ENDPOINT = 14;
   */
  INVALID_ENDPOINT = 14,

  /**
   * Provider specification is invalid
   *
   * @generated from enum value: ERROR_CODE_INVALID_PROVIDER = 15;
   */
  INVALID_PROVIDER = 15,

  /**
   * Plugin is not properly configured
   *
   * @generated from enum value: ERROR_CODE_PLUGIN_NOT_CONFIGURED = 16;
   */
  PLUGIN_NOT_CONFIGURED = 16,
}
// Retrieve enum metadata with: proto3.getEnumType(ErrorCode)
proto3.util.setEnumType(ErrorCode, "finfocus.v1.ErrorCode", [
  { no: 0, name: "ERROR_CODE_UNSPECIFIED" },
  { no: 1, name: "ERROR_CODE_NETWORK_TIMEOUT" },
  { no: 2, name: "ERROR_CODE_SERVICE_UNAVAILABLE" },
  { no: 3, name: "ERROR_CODE_RATE_LIMITED" },
  { no: 4, name: "ERROR_CODE_TEMPORARY_FAILURE" },
  { no: 5, name: "ERROR_CODE_CIRCUIT_OPEN" },
  { no: 6, name: "ERROR_CODE_INVALID_RESOURCE" },
  { no: 7, name: "ERROR_CODE_RESOURCE_NOT_FOUND" },
  { no: 8, name: "ERROR_CODE_INVALID_TIME_RANGE" },
  { no: 9, name: "ERROR_CODE_UNSUPPORTED_REGION" },
  { no: 10, name: "ERROR_CODE_PERMISSION_DENIED" },
  { no: 11, name: "ERROR_CODE_DATA_CORRUPTION" },
  { no: 12, name: "ERROR_CODE_INVALID_CREDENTIALS" },
  { no: 13, name: "ERROR_CODE_MISSING_API_KEY" },
  { no: 14, name: "ERROR_CODE_INVALID_ENDPOINT" },
  { no: 15, name: "ERROR_CODE_INVALID_PROVIDER" },
  { no: 16, name: "ERROR_CODE_PLUGIN_NOT_CONFIGURED" },
]);

/**
 * MetricType represents the type of metric being reported.
 *
 * @generated from enum finfocus.v1.MetricType
 */
export enum MetricType {
  /**
   * @generated from enum value: METRIC_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: METRIC_TYPE_COUNTER = 1;
   */
  COUNTER = 1,

  /**
   * @generated from enum value: METRIC_TYPE_GAUGE = 2;
   */
  GAUGE = 2,

  /**
   * @generated from enum value: METRIC_TYPE_HISTOGRAM = 3;
   */
  HISTOGRAM = 3,

  /**
   * @generated from enum value: METRIC_TYPE_SUMMARY = 4;
   */
  SUMMARY = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(MetricType)
proto3.util.setEnumType(MetricType, "finfocus.v1.MetricType", [
  { no: 0, name: "METRIC_TYPE_UNSPECIFIED" },
  { no: 1, name: "METRIC_TYPE_COUNTER" },
  { no: 2, name: "METRIC_TYPE_GAUGE" },
  { no: 3, name: "METRIC_TYPE_HISTOGRAM" },
  { no: 4, name: "METRIC_TYPE_SUMMARY" },
]);

/**
 * SLIStatus represents whether an SLI is meeting its target.
 *
 * @generated from enum finfocus.v1.SLIStatus
 */
export enum SLIStatus {
  /**
   * @generated from enum value: SLI_STATUS_UNSPECIFIED = 0;
   */
  SLI_STATUS_UNSPECIFIED = 0,

  /**
   * @generated from enum value: SLI_STATUS_MEETING_TARGET = 1;
   */
  SLI_STATUS_MEETING_TARGET = 1,

  /**
   * @generated from enum value: SLI_STATUS_WARNING = 2;
   */
  SLI_STATUS_WARNING = 2,

  /**
   * @generated from enum value: SLI_STATUS_CRITICAL = 3;
   */
  SLI_STATUS_CRITICAL = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(SLIStatus)
proto3.util.setEnumType(SLIStatus, "finfocus.v1.SLIStatus", [
  { no: 0, name: "SLI_STATUS_UNSPECIFIED" },
  { no: 1, name: "SLI_STATUS_MEETING_TARGET" },
  { no: 2, name: "SLI_STATUS_WARNING" },
  { no: 3, name: "SLI_STATUS_CRITICAL" },
]);

/**
 * RecommendationCategory classifies the type of optimization recommendation.
 *
 * @generated from enum finfocus.v1.RecommendationCategory
 */
export enum RecommendationCategory {
  /**
   * @generated from enum value: RECOMMENDATION_CATEGORY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: RECOMMENDATION_CATEGORY_COST = 1;
   */
  COST = 1,

  /**
   * @generated from enum value: RECOMMENDATION_CATEGORY_PERFORMANCE = 2;
   */
  PERFORMANCE = 2,

  /**
   * @generated from enum value: RECOMMENDATION_CATEGORY_SECURITY = 3;
   */
  SECURITY = 3,

  /**
   * @generated from enum value: RECOMMENDATION_CATEGORY_RELIABILITY = 4;
   */
  RELIABILITY = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(RecommendationCategory)
proto3.util.setEnumType(RecommendationCategory, "finfocus.v1.RecommendationCategory", [
  { no: 0, name: "RECOMMENDATION_CATEGORY_UNSPECIFIED" },
  { no: 1, name: "RECOMMENDATION_CATEGORY_COST" },
  { no: 2, name: "RECOMMENDATION_CATEGORY_PERFORMANCE" },
  { no: 3, name: "RECOMMENDATION_CATEGORY_SECURITY" },
  { no: 4, name: "RECOMMENDATION_CATEGORY_RELIABILITY" },
]);

/**
 * RecommendationActionType specifies the type of action recommended.
 *
 * @generated from enum finfocus.v1.RecommendationActionType
 */
export enum RecommendationActionType {
  /**
   * @generated from enum value: RECOMMENDATION_ACTION_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: RECOMMENDATION_ACTION_TYPE_RIGHTSIZE = 1;
   */
  RIGHTSIZE = 1,

  /**
   * @generated from enum value: RECOMMENDATION_ACTION_TYPE_TERMINATE = 2;
   */
  TERMINATE = 2,

  /**
   * @generated from enum value: RECOMMENDATION_ACTION_TYPE_PURCHASE_COMMITMENT = 3;
   */
  PURCHASE_COMMITMENT = 3,

  /**
   * @generated from enum value: RECOMMENDATION_ACTION_TYPE_ADJUST_REQUESTS = 4;
   */
  ADJUST_REQUESTS = 4,

  /**
   * @generated from enum value: RECOMMENDATION_ACTION_TYPE_MODIFY = 5;
   */
  MODIFY = 5,

  /**
   * @generated from enum value: RECOMMENDATION_ACTION_TYPE_DELETE_UNUSED = 6;
   */
  DELETE_UNUSED = 6,

  /**
   * Move workloads to different regions, zones, or SKUs for cost optimization.
   * Common in Azure Advisor (region migration) and GCP Recommender (zone migration).
   * Use ModifyAction with modification_type="region_migration" or "zone_migration".
   *
   * @generated from enum value: RECOMMENDATION_ACTION_TYPE_MIGRATE = 7;
   */
  MIGRATE = 7,

  /**
   * Combine multiple smaller resources into fewer, larger ones for efficiency.
   * Common in Azure Advisor and Kubecost for node consolidation.
   * Use ModifyAction with modification_type="node_consolidation" or "resource_merge".
   *
   * @generated from enum value: RECOMMENDATION_ACTION_TYPE_CONSOLIDATE = 8;
   */
  CONSOLIDATE = 8,

  /**
   * Start/stop resources on a schedule (e.g., dev/test environments).
   * Common in AWS Instance Scheduler and Azure Automation.
   * Use ModifyAction with modification_type="start_stop_schedule".
   *
   * @generated from enum value: RECOMMENDATION_ACTION_TYPE_SCHEDULE = 9;
   */
  SCHEDULE = 9,

  /**
   * Architectural changes such as moving to serverless or managed services.
   * Common in GCP Recommender for App Engine/Cloud Run migration suggestions.
   * Use ModifyAction with modification_type="serverless_migration" or "service_upgrade".
   *
   * @generated from enum value: RECOMMENDATION_ACTION_TYPE_REFACTOR = 10;
   */
  REFACTOR = 10,

  /**
   * Catch-all for provider-specific recommendations not fitting other categories.
   * Use when no other action type accurately describes the recommendation.
   * Include details in Recommendation.metadata or Recommendation.description.
   *
   * @generated from enum value: RECOMMENDATION_ACTION_TYPE_OTHER = 11;
   */
  OTHER = 11,
}
// Retrieve enum metadata with: proto3.getEnumType(RecommendationActionType)
proto3.util.setEnumType(RecommendationActionType, "finfocus.v1.RecommendationActionType", [
  { no: 0, name: "RECOMMENDATION_ACTION_TYPE_UNSPECIFIED" },
  { no: 1, name: "RECOMMENDATION_ACTION_TYPE_RIGHTSIZE" },
  { no: 2, name: "RECOMMENDATION_ACTION_TYPE_TERMINATE" },
  { no: 3, name: "RECOMMENDATION_ACTION_TYPE_PURCHASE_COMMITMENT" },
  { no: 4, name: "RECOMMENDATION_ACTION_TYPE_ADJUST_REQUESTS" },
  { no: 5, name: "RECOMMENDATION_ACTION_TYPE_MODIFY" },
  { no: 6, name: "RECOMMENDATION_ACTION_TYPE_DELETE_UNUSED" },
  { no: 7, name: "RECOMMENDATION_ACTION_TYPE_MIGRATE" },
  { no: 8, name: "RECOMMENDATION_ACTION_TYPE_CONSOLIDATE" },
  { no: 9, name: "RECOMMENDATION_ACTION_TYPE_SCHEDULE" },
  { no: 10, name: "RECOMMENDATION_ACTION_TYPE_REFACTOR" },
  { no: 11, name: "RECOMMENDATION_ACTION_TYPE_OTHER" },
]);

/**
 * RecommendationPriority indicates the urgency of a recommendation.
 *
 * @generated from enum finfocus.v1.RecommendationPriority
 */
export enum RecommendationPriority {
  /**
   * @generated from enum value: RECOMMENDATION_PRIORITY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: RECOMMENDATION_PRIORITY_LOW = 1;
   */
  LOW = 1,

  /**
   * @generated from enum value: RECOMMENDATION_PRIORITY_MEDIUM = 2;
   */
  MEDIUM = 2,

  /**
   * @generated from enum value: RECOMMENDATION_PRIORITY_HIGH = 3;
   */
  HIGH = 3,

  /**
   * @generated from enum value: RECOMMENDATION_PRIORITY_CRITICAL = 4;
   */
  CRITICAL = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(RecommendationPriority)
proto3.util.setEnumType(RecommendationPriority, "finfocus.v1.RecommendationPriority", [
  { no: 0, name: "RECOMMENDATION_PRIORITY_UNSPECIFIED" },
  { no: 1, name: "RECOMMENDATION_PRIORITY_LOW" },
  { no: 2, name: "RECOMMENDATION_PRIORITY_MEDIUM" },
  { no: 3, name: "RECOMMENDATION_PRIORITY_HIGH" },
  { no: 4, name: "RECOMMENDATION_PRIORITY_CRITICAL" },
]);

/**
 * RecommendationSortBy specifies the field to sort recommendations by.
 *
 * @generated from enum finfocus.v1.RecommendationSortBy
 */
export enum RecommendationSortBy {
  /**
   * @generated from enum value: RECOMMENDATION_SORT_BY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: RECOMMENDATION_SORT_BY_ESTIMATED_SAVINGS = 1;
   */
  ESTIMATED_SAVINGS = 1,

  /**
   * @generated from enum value: RECOMMENDATION_SORT_BY_PRIORITY = 2;
   */
  PRIORITY = 2,

  /**
   * @generated from enum value: RECOMMENDATION_SORT_BY_CREATED_AT = 3;
   */
  CREATED_AT = 3,

  /**
   * @generated from enum value: RECOMMENDATION_SORT_BY_CONFIDENCE = 4;
   */
  CONFIDENCE = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(RecommendationSortBy)
proto3.util.setEnumType(RecommendationSortBy, "finfocus.v1.RecommendationSortBy", [
  { no: 0, name: "RECOMMENDATION_SORT_BY_UNSPECIFIED" },
  { no: 1, name: "RECOMMENDATION_SORT_BY_ESTIMATED_SAVINGS" },
  { no: 2, name: "RECOMMENDATION_SORT_BY_PRIORITY" },
  { no: 3, name: "RECOMMENDATION_SORT_BY_CREATED_AT" },
  { no: 4, name: "RECOMMENDATION_SORT_BY_CONFIDENCE" },
]);

/**
 * SortOrder specifies ascending or descending sort order.
 *
 * @generated from enum finfocus.v1.SortOrder
 */
export enum SortOrder {
  /**
   * @generated from enum value: SORT_ORDER_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SORT_ORDER_ASC = 1;
   */
  ASC = 1,

  /**
   * @generated from enum value: SORT_ORDER_DESC = 2;
   */
  DESC = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(SortOrder)
proto3.util.setEnumType(SortOrder, "finfocus.v1.SortOrder", [
  { no: 0, name: "SORT_ORDER_UNSPECIFIED" },
  { no: 1, name: "SORT_ORDER_ASC" },
  { no: 2, name: "SORT_ORDER_DESC" },
]);

/**
 * DismissalReason specifies why a recommendation was dismissed.
 *
 * @generated from enum finfocus.v1.DismissalReason
 */
export enum DismissalReason {
  /**
   * @generated from enum value: DISMISSAL_REASON_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * User determined the recommendation is not applicable to their use case
   *
   * @generated from enum value: DISMISSAL_REASON_NOT_APPLICABLE = 1;
   */
  NOT_APPLICABLE = 1,

  /**
   * Recommendation was already implemented through other means
   *
   * @generated from enum value: DISMISSAL_REASON_ALREADY_IMPLEMENTED = 2;
   */
  ALREADY_IMPLEMENTED = 2,

  /**
   * Business requirements prevent implementing this recommendation
   *
   * @generated from enum value: DISMISSAL_REASON_BUSINESS_CONSTRAINT = 3;
   */
  BUSINESS_CONSTRAINT = 3,

  /**
   * Technical constraints prevent implementing this recommendation
   *
   * @generated from enum value: DISMISSAL_REASON_TECHNICAL_CONSTRAINT = 4;
   */
  TECHNICAL_CONSTRAINT = 4,

  /**
   * User plans to implement later, dismissing temporarily
   *
   * @generated from enum value: DISMISSAL_REASON_DEFERRED = 5;
   */
  DEFERRED = 5,

  /**
   * Recommendation is inaccurate or based on incorrect data
   *
   * @generated from enum value: DISMISSAL_REASON_INACCURATE = 6;
   */
  INACCURATE = 6,

  /**
   * Other reason (see custom_reason field)
   *
   * @generated from enum value: DISMISSAL_REASON_OTHER = 7;
   */
  OTHER = 7,
}
// Retrieve enum metadata with: proto3.getEnumType(DismissalReason)
proto3.util.setEnumType(DismissalReason, "finfocus.v1.DismissalReason", [
  { no: 0, name: "DISMISSAL_REASON_UNSPECIFIED" },
  { no: 1, name: "DISMISSAL_REASON_NOT_APPLICABLE" },
  { no: 2, name: "DISMISSAL_REASON_ALREADY_IMPLEMENTED" },
  { no: 3, name: "DISMISSAL_REASON_BUSINESS_CONSTRAINT" },
  { no: 4, name: "DISMISSAL_REASON_TECHNICAL_CONSTRAINT" },
  { no: 5, name: "DISMISSAL_REASON_DEFERRED" },
  { no: 6, name: "DISMISSAL_REASON_INACCURATE" },
  { no: 7, name: "DISMISSAL_REASON_OTHER" },
]);

/**
 * NameRequest is used for the Name RPC call (empty request).
 *
 * @generated from message finfocus.v1.NameRequest
 */
export class NameRequest extends Message<NameRequest> {
  constructor(data?: PartialMessage<NameRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.NameRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NameRequest {
    return new NameRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NameRequest {
    return new NameRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NameRequest {
    return new NameRequest().fromJsonString(jsonString, options);
  }

  static equals(a: NameRequest | PlainMessage<NameRequest> | undefined, b: NameRequest | PlainMessage<NameRequest> | undefined): boolean {
    return proto3.util.equals(NameRequest, a, b);
  }
}

/**
 * NameResponse contains the plugin name information.
 *
 * @generated from message finfocus.v1.NameResponse
 */
export class NameResponse extends Message<NameResponse> {
  /**
   * name is the display name of the cost source plugin (e.g., "kubecost", "cloudability")
   *
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<NameResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.NameResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NameResponse {
    return new NameResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NameResponse {
    return new NameResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NameResponse {
    return new NameResponse().fromJsonString(jsonString, options);
  }

  static equals(a: NameResponse | PlainMessage<NameResponse> | undefined, b: NameResponse | PlainMessage<NameResponse> | undefined): boolean {
    return proto3.util.equals(NameResponse, a, b);
  }
}

/**
 * ImpactMetric represents a single sustainability impact measurement.
 *
 * @generated from message finfocus.v1.ImpactMetric
 */
export class ImpactMetric extends Message<ImpactMetric> {
  /**
   * kind specifies the type of impact metric (Carbon, Energy, etc.)
   *
   * @generated from field: finfocus.v1.MetricKind kind = 1;
   */
  kind = MetricKind.UNSPECIFIED;

  /**
   * value is the numeric measurement
   *
   * @generated from field: double value = 2;
   */
  value = 0;

  /**
   * unit is the measurement unit (e.g., "gCO2e", "kWh", "L")
   *
   * @generated from field: string unit = 3;
   */
  unit = "";

  constructor(data?: PartialMessage<ImpactMetric>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.ImpactMetric";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "kind", kind: "enum", T: proto3.getEnumType(MetricKind) },
    { no: 2, name: "value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "unit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImpactMetric {
    return new ImpactMetric().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImpactMetric {
    return new ImpactMetric().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImpactMetric {
    return new ImpactMetric().fromJsonString(jsonString, options);
  }

  static equals(a: ImpactMetric | PlainMessage<ImpactMetric> | undefined, b: ImpactMetric | PlainMessage<ImpactMetric> | undefined): boolean {
    return proto3.util.equals(ImpactMetric, a, b);
  }
}

/**
 * SupportsRequest contains the resource descriptor to check support for.
 *
 * @generated from message finfocus.v1.SupportsRequest
 */
export class SupportsRequest extends Message<SupportsRequest> {
  /**
   * resource contains the resource descriptor to check support for
   *
   * @generated from field: finfocus.v1.ResourceDescriptor resource = 1;
   */
  resource?: ResourceDescriptor;

  constructor(data?: PartialMessage<SupportsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.SupportsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource", kind: "message", T: ResourceDescriptor },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SupportsRequest {
    return new SupportsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SupportsRequest {
    return new SupportsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SupportsRequest {
    return new SupportsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SupportsRequest | PlainMessage<SupportsRequest> | undefined, b: SupportsRequest | PlainMessage<SupportsRequest> | undefined): boolean {
    return proto3.util.equals(SupportsRequest, a, b);
  }
}

/**
 * SupportsResponse indicates whether the cost source supports the requested resource.
 *
 * @generated from message finfocus.v1.SupportsResponse
 */
export class SupportsResponse extends Message<SupportsResponse> {
  /**
   * supported indicates if the resource type is supported by this cost source
   *
   * @generated from field: bool supported = 1;
   */
  supported = false;

  /**
   * reason provides optional explanation if supported is false
   *
   * @generated from field: string reason = 2;
   */
  reason = "";

  /**
   * capabilities declares optional capabilities the plugin supports.
   * Standard capability keys:
   *   - "recommendations": Plugin supports GetRecommendations RPC
   *   - "dry_run": Plugin supports DryRun RPC and dry_run flag on cost RPCs
   *   - "budgets": Plugin supports GetBudgets RPC
   * Example: {"recommendations": true, "dry_run": true}
   *
   * @generated from field: map<string, bool> capabilities = 3;
   */
  capabilities: { [key: string]: boolean } = {};

  /**
   * supported_metrics declares optional sustainability metrics the plugin supports
   *
   * @generated from field: repeated finfocus.v1.MetricKind supported_metrics = 4;
   */
  supportedMetrics: MetricKind[] = [];

  /**
   * capabilities_enum declares optional capabilities using strongly-typed enums.
   * This field is automatically populated by the SDK based on implemented interfaces.
   *
   * @generated from field: repeated finfocus.v1.PluginCapability capabilities_enum = 5;
   */
  capabilitiesEnum: PluginCapability[] = [];

  constructor(data?: PartialMessage<SupportsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.SupportsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "supported", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "capabilities", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 8 /* ScalarType.BOOL */} },
    { no: 4, name: "supported_metrics", kind: "enum", T: proto3.getEnumType(MetricKind), repeated: true },
    { no: 5, name: "capabilities_enum", kind: "enum", T: proto3.getEnumType(PluginCapability), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SupportsResponse {
    return new SupportsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SupportsResponse {
    return new SupportsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SupportsResponse {
    return new SupportsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SupportsResponse | PlainMessage<SupportsResponse> | undefined, b: SupportsResponse | PlainMessage<SupportsResponse> | undefined): boolean {
    return proto3.util.equals(SupportsResponse, a, b);
  }
}

/**
 * GetActualCostRequest contains parameters for retrieving historical cost data.
 *
 * @generated from message finfocus.v1.GetActualCostRequest
 */
export class GetActualCostRequest extends Message<GetActualCostRequest> {
  /**
   * resource_id is a flexible ID per plugin (e.g., "i-abc123", "namespace/default")
   *
   * @generated from field: string resource_id = 1;
   */
  resourceId = "";

  /**
   * start timestamp for the cost query period
   *
   * @generated from field: google.protobuf.Timestamp start = 2;
   */
  start?: Timestamp;

  /**
   * end timestamp for the cost query period
   *
   * @generated from field: google.protobuf.Timestamp end = 3;
   */
  end?: Timestamp;

  /**
   * tags provide optional extra filters for cost retrieval
   *
   * @generated from field: map<string, string> tags = 4;
   */
  tags: { [key: string]: string } = {};

  /**
   * New field: Canonical Cloud Identifier (e.g. AWS ARN, Azure Resource ID, GCP Full Resource Name)
   *
   * @generated from field: string arn = 5;
   */
  arn = "";

  /**
   * dry_run when true, returns DryRunResponse in dry_run_result field
   * instead of performing actual cost data retrieval.
   * Default: false (normal cost retrieval behavior).
   * When true, the response will contain dry_run_result instead of results.
   *
   * @generated from field: bool dry_run = 6;
   */
  dryRun = false;

  constructor(data?: PartialMessage<GetActualCostRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.GetActualCostRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "start", kind: "message", T: Timestamp },
    { no: 3, name: "end", kind: "message", T: Timestamp },
    { no: 4, name: "tags", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 5, name: "arn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "dry_run", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetActualCostRequest {
    return new GetActualCostRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetActualCostRequest {
    return new GetActualCostRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetActualCostRequest {
    return new GetActualCostRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetActualCostRequest | PlainMessage<GetActualCostRequest> | undefined, b: GetActualCostRequest | PlainMessage<GetActualCostRequest> | undefined): boolean {
    return proto3.util.equals(GetActualCostRequest, a, b);
  }
}

/**
 * GetActualCostResponse contains the list of actual cost results.
 *
 * @generated from message finfocus.v1.GetActualCostResponse
 */
export class GetActualCostResponse extends Message<GetActualCostResponse> {
  /**
   * results contains the actual cost data points for the requested period
   *
   * @generated from field: repeated finfocus.v1.ActualCostResult results = 1;
   */
  results: ActualCostResult[] = [];

  /**
   * fallback_hint indicates whether the core should attempt to query other plugins
   *
   * @generated from field: finfocus.v1.FallbackHint fallback_hint = 2;
   */
  fallbackHint = FallbackHint.UNSPECIFIED;

  /**
   * dry_run_result contains field mapping information when request.dry_run
   * was true. Empty/nil when dry_run was false or not set.
   * When populated, results field will be empty.
   *
   * @generated from field: finfocus.v1.DryRunResponse dry_run_result = 3;
   */
  dryRunResult?: DryRunResponse;

  constructor(data?: PartialMessage<GetActualCostResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.GetActualCostResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "results", kind: "message", T: ActualCostResult, repeated: true },
    { no: 2, name: "fallback_hint", kind: "enum", T: proto3.getEnumType(FallbackHint) },
    { no: 3, name: "dry_run_result", kind: "message", T: DryRunResponse },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetActualCostResponse {
    return new GetActualCostResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetActualCostResponse {
    return new GetActualCostResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetActualCostResponse {
    return new GetActualCostResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetActualCostResponse | PlainMessage<GetActualCostResponse> | undefined, b: GetActualCostResponse | PlainMessage<GetActualCostResponse> | undefined): boolean {
    return proto3.util.equals(GetActualCostResponse, a, b);
  }
}

/**
 * GetProjectedCostRequest contains the resource descriptor for projected cost calculation.
 *
 * @generated from message finfocus.v1.GetProjectedCostRequest
 */
export class GetProjectedCostRequest extends Message<GetProjectedCostRequest> {
  /**
   * resource contains the resource descriptor for cost projection
   *
   * @generated from field: finfocus.v1.ResourceDescriptor resource = 1;
   */
  resource?: ResourceDescriptor;

  /**
   * utilization_percentage is the global default utilization for all resources in request.
   * Valid range: 0.0 to 1.0 (representing 0% to 100% utilization).
   *
   * NOTE: Due to proto3 semantics, 0.0 cannot be distinguished from "not set".
   * When this field is 0.0 (proto3 default for unset double), the SDK applies
   * a baseline default of 0.5 (50% utilization).
   *
   * To explicitly request 0% utilization, use the resource-level override:
   *   resource.utilization_percentage = proto.Float64(0.0)
   *
   * @generated from field: double utilization_percentage = 2;
   */
  utilizationPercentage = 0;

  /**
   * growth_type overrides ResourceDescriptor.growth_type for this request.
   * OPTIONAL. When set, takes precedence over the resource-level default.
   *
   * Use case: Project different growth scenarios for the same resource
   * without modifying the resource descriptor.
   *
   * When LINEAR or EXPONENTIAL, growth_rate MUST also be provided
   * (either here or in ResourceDescriptor).
   *
   * @generated from field: finfocus.v1.GrowthType growth_type = 3;
   */
  growthType = GrowthType.UNSPECIFIED;

  /**
   * growth_rate overrides ResourceDescriptor.growth_rate for this request.
   * OPTIONAL. When set (even to 0.0), takes precedence over resource-level default.
   *
   * Valid range: >= -1.0 (no upper bound)
   *
   * Proto3 optional field semantics:
   *   - Not set (nil): Use resource-level growth_rate from ResourceDescriptor
   *   - Explicitly set to 0.0: Apply 0% growth (overrides resource default)
   *   - Set to any other value: Use the specified rate
   *
   * In generated Go code, check presence with:
   *   if req.GrowthRate != nil { rate := *req.GrowthRate }
   *
   * Override semantics: If this field is set, it fully replaces
   * ResourceDescriptor.growth_rate for this request.
   *
   * @generated from field: optional double growth_rate = 4;
   */
  growthRate?: number;

  /**
   * dry_run when true, returns DryRunResponse in dry_run_result field
   * instead of performing projected cost calculation.
   * Default: false (normal projection behavior).
   * When true, the response will contain dry_run_result instead of cost data.
   *
   * @generated from field: bool dry_run = 5;
   */
  dryRun = false;

  constructor(data?: PartialMessage<GetProjectedCostRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.GetProjectedCostRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource", kind: "message", T: ResourceDescriptor },
    { no: 2, name: "utilization_percentage", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "growth_type", kind: "enum", T: proto3.getEnumType(GrowthType) },
    { no: 4, name: "growth_rate", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 5, name: "dry_run", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetProjectedCostRequest {
    return new GetProjectedCostRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetProjectedCostRequest {
    return new GetProjectedCostRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetProjectedCostRequest {
    return new GetProjectedCostRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetProjectedCostRequest | PlainMessage<GetProjectedCostRequest> | undefined, b: GetProjectedCostRequest | PlainMessage<GetProjectedCostRequest> | undefined): boolean {
    return proto3.util.equals(GetProjectedCostRequest, a, b);
  }
}

/**
 * GetProjectedCostResponse contains projected cost information.
 *
 * @generated from message finfocus.v1.GetProjectedCostResponse
 */
export class GetProjectedCostResponse extends Message<GetProjectedCostResponse> {
  /**
   * unit_price is the price per unit (aligned with PricingSpec.billing_mode)
   *
   * @generated from field: double unit_price = 1;
   */
  unitPrice = 0;

  /**
   * currency for the pricing (e.g., "USD")
   *
   * @generated from field: string currency = 2;
   */
  currency = "";

  /**
   * cost_per_month is a convenience field for a typical 30-day month
   *
   * @generated from field: double cost_per_month = 3;
   */
  costPerMonth = 0;

  /**
   * billing_detail provides context (e.g., "on-demand", "kubecost-avg-daily")
   *
   * @generated from field: string billing_detail = 4;
   */
  billingDetail = "";

  /**
   * impact_metrics contains sustainability metrics (Carbon, Energy, etc.)
   *
   * @generated from field: repeated finfocus.v1.ImpactMetric impact_metrics = 5;
   */
  impactMetrics: ImpactMetric[] = [];

  /**
   * growth_type is the plugin-reported growth hint for forecasting.
   * Indicates how the resource's cost is expected to grow over time,
   * enabling Core to make smarter forecasts without hardcoded resource-type knowledge.
   *
   * Values:
   *   - GROWTH_TYPE_UNSPECIFIED/NONE: Consumption-based (e.g., EC2, Lambda)
   *     Cost is stable unless usage changes. No accumulation pattern.
   *   - GROWTH_TYPE_LINEAR: Accumulation-based (e.g., S3, backups, logs)
   *     Storage or data grows over time at a predictable rate.
   *   - GROWTH_TYPE_EXPONENTIAL: Compounding growth pattern
   *     Rare in practice; use for resources with exponential data growth.
   *
   * This field is OPTIONAL. When unset (UNSPECIFIED), Core should treat
   * the resource as consumption-based (no growth assumption).
   *
   * @generated from field: finfocus.v1.GrowthType growth_type = 6;
   */
  growthType = GrowthType.UNSPECIFIED;

  /**
   * dry_run_result contains field mapping information when request.dry_run
   * was true. Empty/nil when dry_run was false or not set.
   * When populated, cost fields will be empty/zero.
   *
   * @generated from field: finfocus.v1.DryRunResponse dry_run_result = 7;
   */
  dryRunResult?: DryRunResponse;

  constructor(data?: PartialMessage<GetProjectedCostResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.GetProjectedCostResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "unit_price", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "currency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cost_per_month", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "billing_detail", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "impact_metrics", kind: "message", T: ImpactMetric, repeated: true },
    { no: 6, name: "growth_type", kind: "enum", T: proto3.getEnumType(GrowthType) },
    { no: 7, name: "dry_run_result", kind: "message", T: DryRunResponse },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetProjectedCostResponse {
    return new GetProjectedCostResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetProjectedCostResponse {
    return new GetProjectedCostResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetProjectedCostResponse {
    return new GetProjectedCostResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetProjectedCostResponse | PlainMessage<GetProjectedCostResponse> | undefined, b: GetProjectedCostResponse | PlainMessage<GetProjectedCostResponse> | undefined): boolean {
    return proto3.util.equals(GetProjectedCostResponse, a, b);
  }
}

/**
 * GetPricingSpecRequest contains the resource descriptor for pricing specification.
 *
 * @generated from message finfocus.v1.GetPricingSpecRequest
 */
export class GetPricingSpecRequest extends Message<GetPricingSpecRequest> {
  /**
   * resource contains the resource descriptor for pricing specification
   *
   * @generated from field: finfocus.v1.ResourceDescriptor resource = 1;
   */
  resource?: ResourceDescriptor;

  constructor(data?: PartialMessage<GetPricingSpecRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.GetPricingSpecRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource", kind: "message", T: ResourceDescriptor },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPricingSpecRequest {
    return new GetPricingSpecRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPricingSpecRequest {
    return new GetPricingSpecRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPricingSpecRequest {
    return new GetPricingSpecRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetPricingSpecRequest | PlainMessage<GetPricingSpecRequest> | undefined, b: GetPricingSpecRequest | PlainMessage<GetPricingSpecRequest> | undefined): boolean {
    return proto3.util.equals(GetPricingSpecRequest, a, b);
  }
}

/**
 * GetPricingSpecResponse contains the detailed pricing specification.
 *
 * @generated from message finfocus.v1.GetPricingSpecResponse
 */
export class GetPricingSpecResponse extends Message<GetPricingSpecResponse> {
  /**
   * spec contains the complete pricing specification for the resource
   *
   * @generated from field: finfocus.v1.PricingSpec spec = 1;
   */
  spec?: PricingSpec;

  constructor(data?: PartialMessage<GetPricingSpecResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.GetPricingSpecResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spec", kind: "message", T: PricingSpec },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPricingSpecResponse {
    return new GetPricingSpecResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPricingSpecResponse {
    return new GetPricingSpecResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPricingSpecResponse {
    return new GetPricingSpecResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetPricingSpecResponse | PlainMessage<GetPricingSpecResponse> | undefined, b: GetPricingSpecResponse | PlainMessage<GetPricingSpecResponse> | undefined): boolean {
    return proto3.util.equals(GetPricingSpecResponse, a, b);
  }
}

/**
 * ResourceDescriptor describes a cloud resource for cost analysis.
 * This message defines the contract between Core and Plugins for resource identification.
 *
 * Field Requirements:
 *   - REQUIRED fields must be non-empty for valid requests
 *   - OPTIONAL fields may be omitted or empty depending on context
 *
 * Validation Rules:
 *   - provider: Must be one of: "aws", "azure", "gcp", "kubernetes", "custom"
 *   - resource_type: Must match the plugin's supported resource types
 *   - sku: Format varies by provider (e.g., "t3.micro" for AWS, "Standard_B1s" for Azure)
 *   - region: Must match provider's region naming (e.g., "us-east-1", "eastus", "us-central1")
 *   - tags: Keys and values should be non-empty strings when provided
 *
 * @generated from message finfocus.v1.ResourceDescriptor
 */
export class ResourceDescriptor extends Message<ResourceDescriptor> {
  /**
   * provider identifies the cloud provider.
   * REQUIRED. Must be one of: "aws", "azure", "gcp", "kubernetes", "custom".
   * Empty or unrecognized values will result in InvalidArgument error.
   *
   * @generated from field: string provider = 1;
   */
  provider = "";

  /**
   * resource_type specifies the type of resource being described.
   * REQUIRED. Must match a resource type supported by the target plugin.
   * Maximum length: 256 characters.
   * Format: Alphanumeric with optional hyphens, colons, slashes (regex: ^[a-zA-Z][a-zA-Z0-9_\-:/]*$)
   * Examples: "ec2", "s3", "k8s-namespace", "aws:ec2/instance:Instance".
   * Empty values will result in InvalidArgument error.
   *
   * @generated from field: string resource_type = 2;
   */
  resourceType = "";

  /**
   * sku is the provider-specific SKU or instance size.
   * OPTIONAL. Required for compute resources, may be omitted for others.
   * Examples:
   *   - AWS: "t3.micro", "m5.large"
   *   - Azure: "Standard_B1s", "Standard_D2s_v3"
   *   - GCP: "e2-micro", "n1-standard-1"
   *   - Kubernetes: typically omitted (use tags for resource specifications)
   *
   * @generated from field: string sku = 3;
   */
  sku = "";

  /**
   * region specifies the deployment region.
   * OPTIONAL. Required for regional resources, omit for global resources.
   * Examples:
   *   - AWS: "us-east-1", "eu-west-1"
   *   - Azure: "eastus", "westeurope"
   *   - GCP: "us-central1", "europe-west1"
   *   - Kubernetes: typically omitted or set to cluster region
   *
   * @generated from field: string region = 4;
   */
  region = "";

  /**
   * tags provide label/tag hints for resource identification and filtering.
   * OPTIONAL. Used for additional resource matching and cost allocation.
   * Examples: {"app": "web", "env": "production", "team": "platform"}
   * Both keys and values should be non-empty when provided.
   *
   * @generated from field: map<string, string> tags = 5;
   */
  tags: { [key: string]: string } = {};

  /**
   * utilization_percentage is a per-resource utilization override (0.0 to 1.0).
   * OPTIONAL. If provided, overrides the global request default.
   *
   * @generated from field: optional double utilization_percentage = 6;
   */
  utilizationPercentage?: number;

  /**
   * id is a client-specified identifier for request/response correlation.
   * OPTIONAL. When provided, plugins MUST include this ID in any
   * recommendations or responses related to this resource, enabling
   * clients to match responses to their original requests in batch operations.
   *
   * The ID is treated as an opaque string - plugins MUST NOT validate or
   * transform this value. Common formats include Pulumi URNs, UUIDs, or
   * application-specific identifiers.
   *
   * Example: "urn:pulumi:prod::myapp::aws:ec2/instance:Instance::webserver"
   *
   * Correlation pattern:
   *   1. Client sets id in ResourceDescriptor
   *   2. Plugin copies id to ResourceRecommendationInfo.id
   *   3. Client matches response to request using id
   *
   * @generated from field: string id = 7;
   */
  id = "";

  /**
   * arn is the canonical cloud resource identifier for exact matching.
   * OPTIONAL. When provided, plugins SHOULD use this for precise resource
   * lookup instead of matching by type/sku/region/tags.
   *
   * This field uses "arn" as the name for consistency with GetActualCostRequest,
   * but accepts canonical identifiers from any cloud provider:
   *
   * AWS ARN:
   *   arn:aws:ec2:us-east-1:123456789012:instance/i-1234567890abcdef0
   *
   * Azure Resource ID:
   *   /subscriptions/{sub-id}/resourceGroups/{rg}/providers/
   *   Microsoft.Compute/virtualMachines/{vm-name}
   *
   * GCP Full Resource Name:
   *   //compute.googleapis.com/projects/{project}/zones/{zone}/instances/{name}
   *
   * Kubernetes Resource:
   *   {cluster}/{namespace}/{kind}/{name} or UID
   *
   * Cloudflare:
   *   {zone-id}/{resource-type}/{resource-id}
   *
   * Matching behavior:
   *   - If arn is provided and valid: Use for exact resource lookup
   *   - If arn is empty or invalid: Fall back to type/sku/region/tags matching
   *   - If arn format is unrecognized: Log warning, use fallback matching
   *
   * Plugins MAY validate the arn format for their provider and SHOULD log
   * a warning if the format is invalid before falling back.
   *
   * @generated from field: string arn = 8;
   */
  arn = "";

  /**
   * growth_type specifies the default growth model for cost projections.
   * OPTIONAL. When set, defines how projected costs should grow over time.
   * Can be overridden by GetProjectedCostRequest.growth_type.
   *
   * Values:
   *   - GROWTH_TYPE_UNSPECIFIED/NONE: No growth (constant projections)
   *   - GROWTH_TYPE_LINEAR: Additive growth (cost * (1 + rate * periods))
   *   - GROWTH_TYPE_EXPONENTIAL: Compounding growth (cost * (1 + rate)^periods)
   *
   * When LINEAR or EXPONENTIAL, growth_rate MUST also be provided.
   *
   * @generated from field: finfocus.v1.GrowthType growth_type = 9;
   */
  growthType = GrowthType.UNSPECIFIED;

  /**
   * growth_rate specifies the default growth rate per projection period.
   * OPTIONAL. Required when growth_type is LINEAR or EXPONENTIAL.
   *
   * Valid range: >= -1.0 (no upper bound)
   *   - Positive values: growth (e.g., 0.10 = 10% growth per period)
   *   - Zero: no growth (equivalent to GROWTH_TYPE_NONE)
   *   - Negative values: decline (e.g., -0.10 = 10% decline per period)
   *   - -1.0: complete decline to zero cost
   *
   * Values below -1.0 are invalid (would produce negative costs).
   * Can be overridden by GetProjectedCostRequest.growth_rate.
   *
   * Proto3 optional field semantics:
   *   - Not set (nil): No default rate (caller must provide in request if needed)
   *   - Explicitly set to 0.0: Resource has 0% growth rate as default
   *   - Set to any other value: Use as resource-level default rate
   *
   * In generated Go code, check presence with:
   *   if desc.GrowthRate != nil { rate := *desc.GrowthRate }
   *
   * @generated from field: optional double growth_rate = 10;
   */
  growthRate?: number;

  constructor(data?: PartialMessage<ResourceDescriptor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.ResourceDescriptor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "provider", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "resource_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "sku", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "tags", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 6, name: "utilization_percentage", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 7, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "arn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "growth_type", kind: "enum", T: proto3.getEnumType(GrowthType) },
    { no: 10, name: "growth_rate", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceDescriptor {
    return new ResourceDescriptor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceDescriptor {
    return new ResourceDescriptor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceDescriptor {
    return new ResourceDescriptor().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceDescriptor | PlainMessage<ResourceDescriptor> | undefined, b: ResourceDescriptor | PlainMessage<ResourceDescriptor> | undefined): boolean {
    return proto3.util.equals(ResourceDescriptor, a, b);
  }
}

/**
 * ActualCostResult represents a single cost data point.
 *
 * @generated from message finfocus.v1.ActualCostResult
 */
export class ActualCostResult extends Message<ActualCostResult> {
  /**
   * timestamp indicates the point-in-time or bucket start for this cost data
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  /**
   * cost is the total cost in the specified currency for the period/bucket
   *
   * @generated from field: double cost = 2;
   */
  cost = 0;

  /**
   * usage_amount is the optional usage amount aligned with BillingMode
   *
   * @generated from field: double usage_amount = 3;
   */
  usageAmount = 0;

  /**
   * usage_unit specifies the unit of usage (e.g., "hour", "GB", "request")
   *
   * @generated from field: string usage_unit = 4;
   */
  usageUnit = "";

  /**
   * source identifies the data source (e.g., "kubecost", "flexera")
   *
   * @generated from field: string source = 5;
   */
  source = "";

  /**
   * focus_record provides the cost data in FOCUS 1.2 format.
   * This field is optional and will eventually replace the legacy fields.
   *
   * @generated from field: finfocus.v1.FocusCostRecord focus_record = 6;
   */
  focusRecord?: FocusCostRecord;

  /**
   * impact_metrics contains sustainability metrics (Carbon, Energy, etc.)
   *
   * @generated from field: repeated finfocus.v1.ImpactMetric impact_metrics = 7;
   */
  impactMetrics: ImpactMetric[] = [];

  constructor(data?: PartialMessage<ActualCostResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.ActualCostResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "message", T: Timestamp },
    { no: 2, name: "cost", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "usage_amount", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "usage_unit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "focus_record", kind: "message", T: FocusCostRecord },
    { no: 7, name: "impact_metrics", kind: "message", T: ImpactMetric, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActualCostResult {
    return new ActualCostResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActualCostResult {
    return new ActualCostResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActualCostResult {
    return new ActualCostResult().fromJsonString(jsonString, options);
  }

  static equals(a: ActualCostResult | PlainMessage<ActualCostResult> | undefined, b: ActualCostResult | PlainMessage<ActualCostResult> | undefined): boolean {
    return proto3.util.equals(ActualCostResult, a, b);
  }
}

/**
 * UsageMetricHint provides guidance on usage metrics for cost calculation.
 *
 * @generated from message finfocus.v1.UsageMetricHint
 */
export class UsageMetricHint extends Message<UsageMetricHint> {
  /**
   * metric specifies the usage metric name (e.g., "vcpu_hours", "storage_gb", "requests")
   *
   * @generated from field: string metric = 1;
   */
  metric = "";

  /**
   * unit specifies the metric unit (e.g., "hour", "GB", "count")
   *
   * @generated from field: string unit = 2;
   */
  unit = "";

  constructor(data?: PartialMessage<UsageMetricHint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.UsageMetricHint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metric", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "unit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UsageMetricHint {
    return new UsageMetricHint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UsageMetricHint {
    return new UsageMetricHint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UsageMetricHint {
    return new UsageMetricHint().fromJsonString(jsonString, options);
  }

  static equals(a: UsageMetricHint | PlainMessage<UsageMetricHint> | undefined, b: UsageMetricHint | PlainMessage<UsageMetricHint> | undefined): boolean {
    return proto3.util.equals(UsageMetricHint, a, b);
  }
}

/**
 * PricingSpec provides detailed pricing information for a specific resource type.
 *
 * @generated from message finfocus.v1.PricingSpec
 */
export class PricingSpec extends Message<PricingSpec> {
  /**
   * provider identifies the cloud provider for this pricing specification
   *
   * @generated from field: string provider = 1;
   */
  provider = "";

  /**
   * resource_type specifies the type of resource being priced
   *
   * @generated from field: string resource_type = 2;
   */
  resourceType = "";

  /**
   * sku is the specific SKU or instance type identifier
   *
   * @generated from field: string sku = 3;
   */
  sku = "";

  /**
   * region specifies the geographic region for pricing
   *
   * @generated from field: string region = 4;
   */
  region = "";

  /**
   * billing_mode defines how the resource is billed 
   * (e.g., "per_hour", "per_gb_month", "per_request", "flat", "per_day", "per_cpu_hour")
   *
   * @generated from field: string billing_mode = 5;
   */
  billingMode = "";

  /**
   * rate_per_unit is the price per billing unit
   *
   * @generated from field: double rate_per_unit = 6;
   */
  ratePerUnit = 0;

  /**
   * currency specifies the pricing currency (e.g., "USD")
   *
   * @generated from field: string currency = 7;
   */
  currency = "";

  /**
   * description provides human-readable description of the pricing
   *
   * @generated from field: string description = 8;
   */
  description = "";

  /**
   * metric_hints provide guidance on relevant usage metrics for cost calculation
   *
   * @generated from field: repeated finfocus.v1.UsageMetricHint metric_hints = 9;
   */
  metricHints: UsageMetricHint[] = [];

  /**
   * plugin_metadata contains plugin-specific extra metadata (keys are not guaranteed to be stable)
   *
   * @generated from field: map<string, string> plugin_metadata = 10;
   */
  pluginMetadata: { [key: string]: string } = {};

  /**
   * source identifies where the pricing model originated
   * (e.g., "aws", "gcp", "azure", "kubecost", "flexera", "cloudability", "spec")
   *
   * @generated from field: string source = 11;
   */
  source = "";

  /**
   * unit specifies the unit of measurement for rate_per_unit
   * (e.g., "hour", "GB-month", "request", "unknown")
   *
   * @generated from field: string unit = 12;
   */
  unit = "";

  /**
   * assumptions contains human-readable strings explaining pricing derivation
   * and any constraints or conditions applied to the pricing calculation
   *
   * @generated from field: repeated string assumptions = 13;
   */
  assumptions: string[] = [];

  /**
   * pricing_tiers contains tiered pricing breakdown for volume-based billing
   * When billing_mode is "tiered", this array contains the pricing tiers
   *
   * @generated from field: repeated finfocus.v1.PricingTier pricing_tiers = 14;
   */
  pricingTiers: PricingTier[] = [];

  constructor(data?: PartialMessage<PricingSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.PricingSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "provider", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "resource_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "sku", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "billing_mode", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "rate_per_unit", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 7, name: "currency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "metric_hints", kind: "message", T: UsageMetricHint, repeated: true },
    { no: 10, name: "plugin_metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 11, name: "source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "unit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "assumptions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 14, name: "pricing_tiers", kind: "message", T: PricingTier, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PricingSpec {
    return new PricingSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PricingSpec {
    return new PricingSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PricingSpec {
    return new PricingSpec().fromJsonString(jsonString, options);
  }

  static equals(a: PricingSpec | PlainMessage<PricingSpec> | undefined, b: PricingSpec | PlainMessage<PricingSpec> | undefined): boolean {
    return proto3.util.equals(PricingSpec, a, b);
  }
}

/**
 * PricingTier represents one tier in a tiered pricing model.
 * Used for volume-based pricing where rates decrease at higher usage levels.
 *
 * @generated from message finfocus.v1.PricingTier
 */
export class PricingTier extends Message<PricingTier> {
  /**
   * min_quantity is the lower bound of this tier (inclusive)
   *
   * @generated from field: double min_quantity = 1;
   */
  minQuantity = 0;

  /**
   * max_quantity is the upper bound of this tier (exclusive, 0 means unlimited)
   *
   * @generated from field: double max_quantity = 2;
   */
  maxQuantity = 0;

  /**
   * rate_per_unit is the price per unit within this tier
   *
   * @generated from field: double rate_per_unit = 3;
   */
  ratePerUnit = 0;

  /**
   * description provides human-readable explanation of this tier
   *
   * @generated from field: string description = 4;
   */
  description = "";

  constructor(data?: PartialMessage<PricingTier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.PricingTier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min_quantity", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "max_quantity", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "rate_per_unit", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PricingTier {
    return new PricingTier().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PricingTier {
    return new PricingTier().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PricingTier {
    return new PricingTier().fromJsonString(jsonString, options);
  }

  static equals(a: PricingTier | PlainMessage<PricingTier> | undefined, b: PricingTier | PlainMessage<PricingTier> | undefined): boolean {
    return proto3.util.equals(PricingTier, a, b);
  }
}

/**
 * ErrorDetail provides detailed information about an error.
 *
 * @generated from message finfocus.v1.ErrorDetail
 */
export class ErrorDetail extends Message<ErrorDetail> {
  /**
   * code is the specific error code
   *
   * @generated from field: finfocus.v1.ErrorCode code = 1;
   */
  code = ErrorCode.UNSPECIFIED;

  /**
   * category is the error category (transient, permanent, configuration)
   *
   * @generated from field: finfocus.v1.ErrorCategory category = 2;
   */
  category = ErrorCategory.UNSPECIFIED;

  /**
   * message is the human-readable error message
   *
   * @generated from field: string message = 3;
   */
  message = "";

  /**
   * details contains structured error details
   *
   * @generated from field: map<string, string> details = 4;
   */
  details: { [key: string]: string } = {};

  /**
   * retry_after_seconds suggests when to retry (for transient errors)
   *
   * @generated from field: optional int32 retry_after_seconds = 5;
   */
  retryAfterSeconds?: number;

  /**
   * timestamp when the error occurred
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 6;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<ErrorDetail>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.ErrorDetail";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(ErrorCode) },
    { no: 2, name: "category", kind: "enum", T: proto3.getEnumType(ErrorCategory) },
    { no: 3, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "details", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 5, name: "retry_after_seconds", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 6, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ErrorDetail {
    return new ErrorDetail().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ErrorDetail {
    return new ErrorDetail().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ErrorDetail {
    return new ErrorDetail().fromJsonString(jsonString, options);
  }

  static equals(a: ErrorDetail | PlainMessage<ErrorDetail> | undefined, b: ErrorDetail | PlainMessage<ErrorDetail> | undefined): boolean {
    return proto3.util.equals(ErrorDetail, a, b);
  }
}

/**
 * HealthCheckRequest is used for the HealthCheck RPC call.
 *
 * @generated from message finfocus.v1.HealthCheckRequest
 */
export class HealthCheckRequest extends Message<HealthCheckRequest> {
  /**
   * service_name optionally specifies which service to check (empty for overall health)
   *
   * @generated from field: string service_name = 1;
   */
  serviceName = "";

  constructor(data?: PartialMessage<HealthCheckRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.HealthCheckRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "service_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HealthCheckRequest {
    return new HealthCheckRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HealthCheckRequest {
    return new HealthCheckRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HealthCheckRequest {
    return new HealthCheckRequest().fromJsonString(jsonString, options);
  }

  static equals(a: HealthCheckRequest | PlainMessage<HealthCheckRequest> | undefined, b: HealthCheckRequest | PlainMessage<HealthCheckRequest> | undefined): boolean {
    return proto3.util.equals(HealthCheckRequest, a, b);
  }
}

/**
 * HealthCheckResponse contains the health status of the plugin.
 *
 * @generated from message finfocus.v1.HealthCheckResponse
 */
export class HealthCheckResponse extends Message<HealthCheckResponse> {
  /**
   * status indicates the current health status
   *
   * @generated from field: finfocus.v1.HealthCheckResponse.Status status = 1;
   */
  status = HealthCheckResponse_Status.UNSPECIFIED;

  /**
   * message provides optional details about the health status
   *
   * @generated from field: string message = 2;
   */
  message = "";

  /**
   * last_check_time indicates when this status was last updated
   *
   * @generated from field: google.protobuf.Timestamp last_check_time = 3;
   */
  lastCheckTime?: Timestamp;

  constructor(data?: PartialMessage<HealthCheckResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.HealthCheckResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(HealthCheckResponse_Status) },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "last_check_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HealthCheckResponse {
    return new HealthCheckResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HealthCheckResponse {
    return new HealthCheckResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HealthCheckResponse {
    return new HealthCheckResponse().fromJsonString(jsonString, options);
  }

  static equals(a: HealthCheckResponse | PlainMessage<HealthCheckResponse> | undefined, b: HealthCheckResponse | PlainMessage<HealthCheckResponse> | undefined): boolean {
    return proto3.util.equals(HealthCheckResponse, a, b);
  }
}

/**
 * Status represents the health check status
 *
 * @generated from enum finfocus.v1.HealthCheckResponse.Status
 */
export enum HealthCheckResponse_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATUS_SERVING = 1;
   */
  SERVING = 1,

  /**
   * @generated from enum value: STATUS_NOT_SERVING = 2;
   */
  NOT_SERVING = 2,

  /**
   * @generated from enum value: STATUS_SERVICE_UNKNOWN = 3;
   */
  SERVICE_UNKNOWN = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(HealthCheckResponse_Status)
proto3.util.setEnumType(HealthCheckResponse_Status, "finfocus.v1.HealthCheckResponse.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "STATUS_SERVING" },
  { no: 2, name: "STATUS_NOT_SERVING" },
  { no: 3, name: "STATUS_SERVICE_UNKNOWN" },
]);

/**
 * GetMetricsRequest contains parameters for retrieving plugin metrics.
 *
 * @generated from message finfocus.v1.GetMetricsRequest
 */
export class GetMetricsRequest extends Message<GetMetricsRequest> {
  /**
   * metric_names optionally filters which metrics to return (empty for all)
   *
   * @generated from field: repeated string metric_names = 1;
   */
  metricNames: string[] = [];

  /**
   * format specifies the output format (e.g., "prometheus", "json")
   *
   * @generated from field: string format = 2;
   */
  format = "";

  constructor(data?: PartialMessage<GetMetricsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.GetMetricsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metric_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "format", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetMetricsRequest {
    return new GetMetricsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetMetricsRequest {
    return new GetMetricsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetMetricsRequest {
    return new GetMetricsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetMetricsRequest | PlainMessage<GetMetricsRequest> | undefined, b: GetMetricsRequest | PlainMessage<GetMetricsRequest> | undefined): boolean {
    return proto3.util.equals(GetMetricsRequest, a, b);
  }
}

/**
 * GetMetricsResponse contains the plugin metrics.
 *
 * @generated from message finfocus.v1.GetMetricsResponse
 */
export class GetMetricsResponse extends Message<GetMetricsResponse> {
  /**
   * metrics contains the collected metrics data
   *
   * @generated from field: repeated finfocus.v1.Metric metrics = 1;
   */
  metrics: Metric[] = [];

  /**
   * timestamp indicates when these metrics were collected
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 2;
   */
  timestamp?: Timestamp;

  /**
   * format indicates the format of the metrics data
   *
   * @generated from field: string format = 3;
   */
  format = "";

  constructor(data?: PartialMessage<GetMetricsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.GetMetricsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metrics", kind: "message", T: Metric, repeated: true },
    { no: 2, name: "timestamp", kind: "message", T: Timestamp },
    { no: 3, name: "format", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetMetricsResponse {
    return new GetMetricsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetMetricsResponse {
    return new GetMetricsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetMetricsResponse {
    return new GetMetricsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetMetricsResponse | PlainMessage<GetMetricsResponse> | undefined, b: GetMetricsResponse | PlainMessage<GetMetricsResponse> | undefined): boolean {
    return proto3.util.equals(GetMetricsResponse, a, b);
  }
}

/**
 * Metric represents a single monitoring metric.
 *
 * @generated from message finfocus.v1.Metric
 */
export class Metric extends Message<Metric> {
  /**
   * name is the metric name (e.g., "request_latency_seconds", "requests_total")
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * help provides a description of what the metric measures
   *
   * @generated from field: string help = 2;
   */
  help = "";

  /**
   * type specifies the metric type (counter, gauge, histogram, summary)
   *
   * @generated from field: finfocus.v1.MetricType type = 3;
   */
  type = MetricType.UNSPECIFIED;

  /**
   * samples contains the metric data points
   *
   * @generated from field: repeated finfocus.v1.MetricSample samples = 4;
   */
  samples: MetricSample[] = [];

  constructor(data?: PartialMessage<Metric>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.Metric";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "help", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "type", kind: "enum", T: proto3.getEnumType(MetricType) },
    { no: 4, name: "samples", kind: "message", T: MetricSample, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Metric {
    return new Metric().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Metric {
    return new Metric().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Metric {
    return new Metric().fromJsonString(jsonString, options);
  }

  static equals(a: Metric | PlainMessage<Metric> | undefined, b: Metric | PlainMessage<Metric> | undefined): boolean {
    return proto3.util.equals(Metric, a, b);
  }
}

/**
 * MetricSample represents a single metric measurement.
 *
 * @generated from message finfocus.v1.MetricSample
 */
export class MetricSample extends Message<MetricSample> {
  /**
   * labels contains key-value pairs for metric dimensions
   *
   * @generated from field: map<string, string> labels = 1;
   */
  labels: { [key: string]: string } = {};

  /**
   * value is the numeric value of this metric sample
   *
   * @generated from field: double value = 2;
   */
  value = 0;

  /**
   * timestamp indicates when this sample was recorded
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 3;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<MetricSample>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.MetricSample";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 2, name: "value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricSample {
    return new MetricSample().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricSample {
    return new MetricSample().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricSample {
    return new MetricSample().fromJsonString(jsonString, options);
  }

  static equals(a: MetricSample | PlainMessage<MetricSample> | undefined, b: MetricSample | PlainMessage<MetricSample> | undefined): boolean {
    return proto3.util.equals(MetricSample, a, b);
  }
}

/**
 * GetServiceLevelIndicatorsRequest contains parameters for retrieving Service Level Indicators.
 *
 * @generated from message finfocus.v1.GetServiceLevelIndicatorsRequest
 */
export class GetServiceLevelIndicatorsRequest extends Message<GetServiceLevelIndicatorsRequest> {
  /**
   * time_range optionally specifies the time range for SLI calculation
   *
   * @generated from field: finfocus.v1.TimeRange time_range = 1;
   */
  timeRange?: TimeRange;

  /**
   * sli_names optionally filters which SLIs to return (empty for all)
   *
   * @generated from field: repeated string sli_names = 2;
   */
  sliNames: string[] = [];

  constructor(data?: PartialMessage<GetServiceLevelIndicatorsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.GetServiceLevelIndicatorsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "time_range", kind: "message", T: TimeRange },
    { no: 2, name: "sli_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetServiceLevelIndicatorsRequest {
    return new GetServiceLevelIndicatorsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetServiceLevelIndicatorsRequest {
    return new GetServiceLevelIndicatorsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetServiceLevelIndicatorsRequest {
    return new GetServiceLevelIndicatorsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetServiceLevelIndicatorsRequest | PlainMessage<GetServiceLevelIndicatorsRequest> | undefined, b: GetServiceLevelIndicatorsRequest | PlainMessage<GetServiceLevelIndicatorsRequest> | undefined): boolean {
    return proto3.util.equals(GetServiceLevelIndicatorsRequest, a, b);
  }
}

/**
 * GetServiceLevelIndicatorsResponse contains the current Service Level Indicators.
 *
 * @generated from message finfocus.v1.GetServiceLevelIndicatorsResponse
 */
export class GetServiceLevelIndicatorsResponse extends Message<GetServiceLevelIndicatorsResponse> {
  /**
   * slis contains the current SLI measurements
   *
   * @generated from field: repeated finfocus.v1.ServiceLevelIndicator slis = 1;
   */
  slis: ServiceLevelIndicator[] = [];

  /**
   * measurement_time indicates when these SLIs were measured
   *
   * @generated from field: google.protobuf.Timestamp measurement_time = 2;
   */
  measurementTime?: Timestamp;

  constructor(data?: PartialMessage<GetServiceLevelIndicatorsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.GetServiceLevelIndicatorsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "slis", kind: "message", T: ServiceLevelIndicator, repeated: true },
    { no: 2, name: "measurement_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetServiceLevelIndicatorsResponse {
    return new GetServiceLevelIndicatorsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetServiceLevelIndicatorsResponse {
    return new GetServiceLevelIndicatorsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetServiceLevelIndicatorsResponse {
    return new GetServiceLevelIndicatorsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetServiceLevelIndicatorsResponse | PlainMessage<GetServiceLevelIndicatorsResponse> | undefined, b: GetServiceLevelIndicatorsResponse | PlainMessage<GetServiceLevelIndicatorsResponse> | undefined): boolean {
    return proto3.util.equals(GetServiceLevelIndicatorsResponse, a, b);
  }
}

/**
 * ServiceLevelIndicator represents a measurable aspect of service quality.
 *
 * @generated from message finfocus.v1.ServiceLevelIndicator
 */
export class ServiceLevelIndicator extends Message<ServiceLevelIndicator> {
  /**
   * name is the SLI name (e.g., "availability", "latency_p99", "error_rate")
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * description explains what this SLI measures
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * value is the current SLI value (e.g., 0.995 for 99.5% availability)
   *
   * @generated from field: double value = 3;
   */
  value = 0;

  /**
   * unit specifies the unit of measurement (e.g., "percentage", "seconds", "ratio")
   *
   * @generated from field: string unit = 4;
   */
  unit = "";

  /**
   * target_value is the target/goal value for this SLI
   *
   * @generated from field: double target_value = 5;
   */
  targetValue = 0;

  /**
   * status indicates if the SLI is meeting its target
   *
   * @generated from field: finfocus.v1.SLIStatus status = 6;
   */
  status = SLIStatus.SLI_STATUS_UNSPECIFIED;

  constructor(data?: PartialMessage<ServiceLevelIndicator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.ServiceLevelIndicator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "unit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "target_value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 6, name: "status", kind: "enum", T: proto3.getEnumType(SLIStatus) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServiceLevelIndicator {
    return new ServiceLevelIndicator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServiceLevelIndicator {
    return new ServiceLevelIndicator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServiceLevelIndicator {
    return new ServiceLevelIndicator().fromJsonString(jsonString, options);
  }

  static equals(a: ServiceLevelIndicator | PlainMessage<ServiceLevelIndicator> | undefined, b: ServiceLevelIndicator | PlainMessage<ServiceLevelIndicator> | undefined): boolean {
    return proto3.util.equals(ServiceLevelIndicator, a, b);
  }
}

/**
 * TimeRange represents a time period for metrics and SLI calculations.
 *
 * @generated from message finfocus.v1.TimeRange
 */
export class TimeRange extends Message<TimeRange> {
  /**
   * start timestamp for the time range
   *
   * @generated from field: google.protobuf.Timestamp start = 1;
   */
  start?: Timestamp;

  /**
   * end timestamp for the time range  
   *
   * @generated from field: google.protobuf.Timestamp end = 2;
   */
  end?: Timestamp;

  constructor(data?: PartialMessage<TimeRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.TimeRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "message", T: Timestamp },
    { no: 2, name: "end", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeRange {
    return new TimeRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeRange {
    return new TimeRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeRange {
    return new TimeRange().fromJsonString(jsonString, options);
  }

  static equals(a: TimeRange | PlainMessage<TimeRange> | undefined, b: TimeRange | PlainMessage<TimeRange> | undefined): boolean {
    return proto3.util.equals(TimeRange, a, b);
  }
}

/**
 * TelemetryMetadata provides observability context for RPC responses.
 * This can be embedded in existing response messages to add telemetry capabilities.
 *
 * @generated from message finfocus.v1.TelemetryMetadata
 */
export class TelemetryMetadata extends Message<TelemetryMetadata> {
  /**
   * trace_id is the distributed trace identifier for request correlation
   *
   * @generated from field: string trace_id = 1;
   */
  traceId = "";

  /**
   * span_id is the current span identifier within the trace
   *
   * @generated from field: string span_id = 2;
   */
  spanId = "";

  /**
   * request_id is a unique identifier for this specific request
   *
   * @generated from field: string request_id = 3;
   */
  requestId = "";

  /**
   * processing_time_ms indicates how long the request took to process
   *
   * @generated from field: int64 processing_time_ms = 4;
   */
  processingTimeMs = protoInt64.zero;

  /**
   * data_source indicates the backend system that provided the data
   *
   * @generated from field: string data_source = 5;
   */
  dataSource = "";

  /**
   * cache_hit indicates if the response came from cache
   *
   * @generated from field: bool cache_hit = 6;
   */
  cacheHit = false;

  /**
   * quality_score optionally indicates the data quality/confidence (0.0-1.0)
   *
   * @generated from field: double quality_score = 7;
   */
  qualityScore = 0;

  constructor(data?: PartialMessage<TelemetryMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.TelemetryMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trace_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "span_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "processing_time_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "data_source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "cache_hit", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "quality_score", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TelemetryMetadata {
    return new TelemetryMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TelemetryMetadata {
    return new TelemetryMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TelemetryMetadata {
    return new TelemetryMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: TelemetryMetadata | PlainMessage<TelemetryMetadata> | undefined, b: TelemetryMetadata | PlainMessage<TelemetryMetadata> | undefined): boolean {
    return proto3.util.equals(TelemetryMetadata, a, b);
  }
}

/**
 * LogEntry represents a structured log entry for standardized logging.
 *
 * @generated from message finfocus.v1.LogEntry
 */
export class LogEntry extends Message<LogEntry> {
  /**
   * timestamp when the log entry was created
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  /**
   * level indicates the log level (e.g., "DEBUG", "INFO", "WARN", "ERROR")
   *
   * @generated from field: string level = 2;
   */
  level = "";

  /**
   * message is the log message content
   *
   * @generated from field: string message = 3;
   */
  message = "";

  /**
   * component identifies the plugin component that generated the log
   *
   * @generated from field: string component = 4;
   */
  component = "";

  /**
   * trace_id for correlating logs with distributed traces
   *
   * @generated from field: string trace_id = 5;
   */
  traceId = "";

  /**
   * span_id for correlating logs with specific spans
   *
   * @generated from field: string span_id = 6;
   */
  spanId = "";

  /**
   * fields contains structured log fields as key-value pairs
   *
   * @generated from field: map<string, string> fields = 7;
   */
  fields: { [key: string]: string } = {};

  /**
   * error_details provides additional context for error logs
   *
   * @generated from field: finfocus.v1.ErrorDetails error_details = 8;
   */
  errorDetails?: ErrorDetails;

  constructor(data?: PartialMessage<LogEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.LogEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "message", T: Timestamp },
    { no: 2, name: "level", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "component", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "trace_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "span_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "fields", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 8, name: "error_details", kind: "message", T: ErrorDetails },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogEntry {
    return new LogEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogEntry {
    return new LogEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogEntry {
    return new LogEntry().fromJsonString(jsonString, options);
  }

  static equals(a: LogEntry | PlainMessage<LogEntry> | undefined, b: LogEntry | PlainMessage<LogEntry> | undefined): boolean {
    return proto3.util.equals(LogEntry, a, b);
  }
}

/**
 * ErrorDetails provides structured error information for logging and debugging.
 *
 * @generated from message finfocus.v1.ErrorDetails
 */
export class ErrorDetails extends Message<ErrorDetails> {
  /**
   * error_code is a machine-readable error identifier
   *
   * @generated from field: string error_code = 1;
   */
  errorCode = "";

  /**
   * error_category classifies the type of error (e.g., "network", "auth", "data")
   *
   * @generated from field: string error_category = 2;
   */
  errorCategory = "";

  /**
   * stack_trace provides debugging information (should be sanitized in production)
   *
   * @generated from field: string stack_trace = 3;
   */
  stackTrace = "";

  /**
   * retry_after_seconds suggests when the client should retry (for transient errors)
   *
   * @generated from field: int32 retry_after_seconds = 4;
   */
  retryAfterSeconds = 0;

  /**
   * correlation_id helps correlate related errors across services
   *
   * @generated from field: string correlation_id = 5;
   */
  correlationId = "";

  constructor(data?: PartialMessage<ErrorDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.ErrorDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "error_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "error_category", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "stack_trace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "retry_after_seconds", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "correlation_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ErrorDetails {
    return new ErrorDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ErrorDetails {
    return new ErrorDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ErrorDetails {
    return new ErrorDetails().fromJsonString(jsonString, options);
  }

  static equals(a: ErrorDetails | PlainMessage<ErrorDetails> | undefined, b: ErrorDetails | PlainMessage<ErrorDetails> | undefined): boolean {
    return proto3.util.equals(ErrorDetails, a, b);
  }
}

/**
 * EstimateCostRequest represents a request to estimate the cost of a Pulumi
 * resource before deployment. This enables "what-if" cost analysis for
 * configuration comparison and budget planning.
 *
 * @generated from message finfocus.v1.EstimateCostRequest
 */
export class EstimateCostRequest extends Message<EstimateCostRequest> {
  /**
   * The full type name of the Pulumi resource to estimate cost for.
   * Must follow the format: "provider:module/resource:Type"
   *
   * Examples:
   *   - "aws:ec2/instance:Instance"
   *   - "azure:compute/virtualMachine:VirtualMachine"
   *   - "gcp:compute/instance:Instance"
   *
   * The resource_type must be supported by the plugin (check via Supports RPC).
   * Invalid formats will return InvalidArgument error.
   *
   * @generated from field: string resource_type = 1;
   */
  resourceType = "";

  /**
   * A structured representation of the resource's input properties.
   * This mirrors the structure of a Pulumi resource declaration.
   *
   * The attributes field may be null or missing, which is treated as an
   * empty struct. The plugin determines which attributes are required for
   * cost estimation based on its pricing model.
   *
   * Examples:
   *   AWS: {"instanceType": "t3.micro", "region": "us-east-1"}
   *   Azure: {"vmSize": "Standard_B1s", "location": "eastus"}
   *   GCP: {"machineType": "e2-micro", "zone": "us-central1-a"}
   *
   * @generated from field: google.protobuf.Struct attributes = 2;
   */
  attributes?: Struct;

  constructor(data?: PartialMessage<EstimateCostRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.EstimateCostRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "attributes", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EstimateCostRequest {
    return new EstimateCostRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EstimateCostRequest {
    return new EstimateCostRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EstimateCostRequest {
    return new EstimateCostRequest().fromJsonString(jsonString, options);
  }

  static equals(a: EstimateCostRequest | PlainMessage<EstimateCostRequest> | undefined, b: EstimateCostRequest | PlainMessage<EstimateCostRequest> | undefined): boolean {
    return proto3.util.equals(EstimateCostRequest, a, b);
  }
}

/**
 * EstimateCostResponse contains the estimated monthly cost for a resource
 * based on the provided configuration.
 *
 * Future versions may add optional breakdown fields (e.g., compute vs storage)
 * while maintaining backward compatibility through optional fields.
 *
 * @generated from message finfocus.v1.EstimateCostResponse
 */
export class EstimateCostResponse extends Message<EstimateCostResponse> {
  /**
   * The currency of the cost, as an ISO 4217 currency code.
   * Typically "USD" but depends on the plugin's pricing source.
   *
   * @generated from field: string currency = 1;
   */
  currency = "";

  /**
   * The estimated monthly cost for the resource.
   * Must be non-negative. Zero is valid for free-tier resources.
   * Monthly cost assumes 730 hours/month for hourly-billed resources.
   *
   * @generated from field: double cost_monthly = 2;
   */
  costMonthly = 0;

  constructor(data?: PartialMessage<EstimateCostResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.EstimateCostResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cost_monthly", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EstimateCostResponse {
    return new EstimateCostResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EstimateCostResponse {
    return new EstimateCostResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EstimateCostResponse {
    return new EstimateCostResponse().fromJsonString(jsonString, options);
  }

  static equals(a: EstimateCostResponse | PlainMessage<EstimateCostResponse> | undefined, b: EstimateCostResponse | PlainMessage<EstimateCostResponse> | undefined): boolean {
    return proto3.util.equals(EstimateCostResponse, a, b);
  }
}

/**
 * GetRecommendationsRequest contains parameters for retrieving recommendations.
 *
 * @generated from message finfocus.v1.GetRecommendationsRequest
 */
export class GetRecommendationsRequest extends Message<GetRecommendationsRequest> {
  /**
   * filter narrows the recommendations returned
   *
   * @generated from field: finfocus.v1.RecommendationFilter filter = 1;
   */
  filter?: RecommendationFilter;

  /**
   * projection_period specifies the time period for savings projection
   * Valid values: "daily", "monthly" (default), "annual"
   *
   * @generated from field: string projection_period = 2;
   */
  projectionPeriod = "";

  /**
   * page_size is the maximum number of recommendations to return (default: 50, max: 1000)
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize = 0;

  /**
   * page_token is the continuation token from a previous response
   *
   * @generated from field: string page_token = 4;
   */
  pageToken = "";

  /**
   * excluded_recommendation_ids contains IDs of recommendations to exclude from results.
   * Use this to filter out recommendations that have been dismissed by users.
   * Plugins should not return recommendations matching these IDs.
   *
   * @generated from field: repeated string excluded_recommendation_ids = 5;
   */
  excludedRecommendationIds: string[] = [];

  /**
   * target_resources specifies the resources to analyze for recommendations.
   * When provided, plugins return recommendations ONLY for these resources.
   * When empty, plugins return recommendations for all resources in scope.
   *
   * Use cases:
   *   - Stack-scoped recommendations: Pass Pulumi stack resources for targeted analysis
   *   - Pre-deployment optimization: Analyze proposed resources before creation
   *   - Batch resource analysis: Query recommendations for a known resource list
   *
   * Interaction with filter:
   *   - target_resources defines the SCOPE (which resources to analyze)
   *   - filter defines SELECTION CRITERIA within that scope (category, priority, etc.)
   *   - Both are applied (AND logic): recommendations must match a target resource
   *     AND satisfy any filter criteria
   *
   * Matching rules:
   *   - provider and resource_type must always match (required fields)
   *   - sku, region, and tags are matched only when specified in the target
   *   - If specified, optional fields must match exactly (strict matching)
   *
   * Validation:
   *   - Maximum 100 resources per request (exceeding returns InvalidArgument)
   *   - Each ResourceDescriptor must have valid provider and resource_type
   *   - Empty target_resources is valid (analyze all resources in scope)
   *
   * @generated from field: repeated finfocus.v1.ResourceDescriptor target_resources = 6;
   */
  targetResources: ResourceDescriptor[] = [];

  constructor(data?: PartialMessage<GetRecommendationsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.GetRecommendationsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filter", kind: "message", T: RecommendationFilter },
    { no: 2, name: "projection_period", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "excluded_recommendation_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "target_resources", kind: "message", T: ResourceDescriptor, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRecommendationsRequest {
    return new GetRecommendationsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRecommendationsRequest {
    return new GetRecommendationsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRecommendationsRequest {
    return new GetRecommendationsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetRecommendationsRequest | PlainMessage<GetRecommendationsRequest> | undefined, b: GetRecommendationsRequest | PlainMessage<GetRecommendationsRequest> | undefined): boolean {
    return proto3.util.equals(GetRecommendationsRequest, a, b);
  }
}

/**
 * GetRecommendationsResponse contains the recommendations and summary.
 *
 * @generated from message finfocus.v1.GetRecommendationsResponse
 */
export class GetRecommendationsResponse extends Message<GetRecommendationsResponse> {
  /**
   * recommendations is the list of cost optimization recommendations
   *
   * @generated from field: repeated finfocus.v1.Recommendation recommendations = 1;
   */
  recommendations: Recommendation[] = [];

  /**
   * summary provides aggregated statistics for the recommendations included
   * in this response page (not across all pages). Clients should aggregate
   * summaries across pages if global totals are needed.
   *
   * @generated from field: finfocus.v1.RecommendationSummary summary = 2;
   */
  summary?: RecommendationSummary;

  /**
   * next_page_token is the token for retrieving the next page (empty if last)
   *
   * @generated from field: string next_page_token = 3;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<GetRecommendationsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.GetRecommendationsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "recommendations", kind: "message", T: Recommendation, repeated: true },
    { no: 2, name: "summary", kind: "message", T: RecommendationSummary },
    { no: 3, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRecommendationsResponse {
    return new GetRecommendationsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRecommendationsResponse {
    return new GetRecommendationsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRecommendationsResponse {
    return new GetRecommendationsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetRecommendationsResponse | PlainMessage<GetRecommendationsResponse> | undefined, b: GetRecommendationsResponse | PlainMessage<GetRecommendationsResponse> | undefined): boolean {
    return proto3.util.equals(GetRecommendationsResponse, a, b);
  }
}

/**
 * RecommendationFilter specifies criteria for filtering recommendations.
 *
 * @generated from message finfocus.v1.RecommendationFilter
 */
export class RecommendationFilter extends Message<RecommendationFilter> {
  /**
   * provider filters by cloud provider (e.g., "aws", "azure", "gcp", "kubernetes")
   *
   * @generated from field: string provider = 1;
   */
  provider = "";

  /**
   * region filters by deployment region
   *
   * @generated from field: string region = 2;
   */
  region = "";

  /**
   * resource_type filters by resource type
   *
   * @generated from field: string resource_type = 3;
   */
  resourceType = "";

  /**
   * category filters by recommendation category
   *
   * @generated from field: finfocus.v1.RecommendationCategory category = 4;
   */
  category = RecommendationCategory.UNSPECIFIED;

  /**
   * action_type filters by recommended action type
   *
   * @generated from field: finfocus.v1.RecommendationActionType action_type = 5;
   */
  actionType = RecommendationActionType.UNSPECIFIED;

  /**
   * sku filters by SKU or instance type (e.g., "t2.medium", "gp2").
   * When provided, plugins generate recommendations for this specific SKU.
   * This enables resource-specific recommendations like instance generation
   * upgrades (t2t3) or Graviton migrations (m5m6g).
   *
   * @generated from field: string sku = 6;
   */
  sku = "";

  /**
   * tags provides additional resource metadata for recommendation generation.
   * Example: {"size": "100"} for EBS volume size, {"env": "prod"} for filtering.
   * Plugins use this metadata to provide context-aware recommendations.
   *
   * @generated from field: map<string, string> tags = 7;
   */
  tags: { [key: string]: string } = {};

  /**
   * priority filters by recommendation priority level.
   * Use to focus on high-impact recommendations during triage.
   *
   * @generated from field: finfocus.v1.RecommendationPriority priority = 8;
   */
  priority = RecommendationPriority.UNSPECIFIED;

  /**
   * min_estimated_savings filters to only include recommendations above this
   * savings threshold. The value is expressed in the same currency as
   * RecommendationImpact.currency and RecommendationSummary.currency.
   * Example: 100.0 to show only recommendations saving at least 100 units of currency.
   *
   * @generated from field: double min_estimated_savings = 9;
   */
  minEstimatedSavings = 0;

  /**
   * source filters by recommendation source (e.g., "aws-cost-explorer",
   * "kubecost", "azure-advisor", "gcp-recommender").
   * Use in multi-source environments to focus on specific backends.
   *
   * @generated from field: string source = 10;
   */
  source = "";

  /**
   * account_id filters by cloud account/subscription/project ID.
   * Essential for multi-account AWS Organizations, Azure subscriptions,
   * or GCP projects. Format is provider-specific.
   *
   * @generated from field: string account_id = 11;
   */
  accountId = "";

  /**
   * sort_by specifies the field to sort recommendations by.
   * Default is UNSPECIFIED (implementation-defined order).
   *
   * @generated from field: finfocus.v1.RecommendationSortBy sort_by = 12;
   */
  sortBy = RecommendationSortBy.UNSPECIFIED;

  /**
   * sort_order specifies ascending or descending sort order.
   * Default is UNSPECIFIED (DESC for savings/priority, ASC for others).
   *
   * @generated from field: finfocus.v1.SortOrder sort_order = 13;
   */
  sortOrder = SortOrder.UNSPECIFIED;

  /**
   * min_confidence_score filters to only include recommendations with
   * confidence score >= this value. Range: 0.0 to 1.0.
   * Use for automated remediation pipelines requiring high confidence.
   *
   * @generated from field: double min_confidence_score = 14;
   */
  minConfidenceScore = 0;

  /**
   * max_age_days filters to only include recommendations created within
   * the last N days. Use to focus on fresh recommendations.
   * Value of 0 means no age filtering (include all).
   *
   * @generated from field: int32 max_age_days = 15;
   */
  maxAgeDays = 0;

  /**
   * resource_id filters for recommendations affecting a specific resource.
   * Format is provider-specific (e.g., AWS instance ID, K8s resource name).
   *
   * @generated from field: string resource_id = 16;
   */
  resourceId = "";

  constructor(data?: PartialMessage<RecommendationFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.RecommendationFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "provider", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "resource_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "category", kind: "enum", T: proto3.getEnumType(RecommendationCategory) },
    { no: 5, name: "action_type", kind: "enum", T: proto3.getEnumType(RecommendationActionType) },
    { no: 6, name: "sku", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "tags", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 8, name: "priority", kind: "enum", T: proto3.getEnumType(RecommendationPriority) },
    { no: 9, name: "min_estimated_savings", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 10, name: "source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "sort_by", kind: "enum", T: proto3.getEnumType(RecommendationSortBy) },
    { no: 13, name: "sort_order", kind: "enum", T: proto3.getEnumType(SortOrder) },
    { no: 14, name: "min_confidence_score", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 15, name: "max_age_days", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 16, name: "resource_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecommendationFilter {
    return new RecommendationFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecommendationFilter {
    return new RecommendationFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecommendationFilter {
    return new RecommendationFilter().fromJsonString(jsonString, options);
  }

  static equals(a: RecommendationFilter | PlainMessage<RecommendationFilter> | undefined, b: RecommendationFilter | PlainMessage<RecommendationFilter> | undefined): boolean {
    return proto3.util.equals(RecommendationFilter, a, b);
  }
}

/**
 * Recommendation represents a single cost optimization recommendation.
 *
 * @generated from message finfocus.v1.Recommendation
 */
export class Recommendation extends Message<Recommendation> {
  /**
   * id is a unique identifier for this recommendation
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * category classifies the type of recommendation
   *
   * @generated from field: finfocus.v1.RecommendationCategory category = 2;
   */
  category = RecommendationCategory.UNSPECIFIED;

  /**
   * action_type specifies what action is recommended
   *
   * @generated from field: finfocus.v1.RecommendationActionType action_type = 3;
   */
  actionType = RecommendationActionType.UNSPECIFIED;

  /**
   * resource contains information about the affected resource
   *
   * @generated from field: finfocus.v1.ResourceRecommendationInfo resource = 4;
   */
  resource?: ResourceRecommendationInfo;

  /**
   * action_detail contains provider-specific action details
   *
   * @generated from oneof finfocus.v1.Recommendation.action_detail
   */
  actionDetail: {
    /**
     * @generated from field: finfocus.v1.RightsizeAction rightsize = 5;
     */
    value: RightsizeAction;
    case: "rightsize";
  } | {
    /**
     * @generated from field: finfocus.v1.TerminateAction terminate = 6;
     */
    value: TerminateAction;
    case: "terminate";
  } | {
    /**
     * @generated from field: finfocus.v1.CommitmentAction commitment = 7;
     */
    value: CommitmentAction;
    case: "commitment";
  } | {
    /**
     * @generated from field: finfocus.v1.KubernetesAction kubernetes = 8;
     */
    value: KubernetesAction;
    case: "kubernetes";
  } | {
    /**
     * @generated from field: finfocus.v1.ModifyAction modify = 9;
     */
    value: ModifyAction;
    case: "modify";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * impact contains the financial impact assessment
   *
   * @generated from field: finfocus.v1.RecommendationImpact impact = 10;
   */
  impact?: RecommendationImpact;

  /**
   * priority indicates the urgency of the recommendation
   *
   * @generated from field: finfocus.v1.RecommendationPriority priority = 11;
   */
  priority = RecommendationPriority.UNSPECIFIED;

  /**
   * confidence_score indicates the confidence level (0.0-1.0), nil if unavailable
   *
   * @generated from field: optional double confidence_score = 12;
   */
  confidenceScore?: number;

  /**
   * description is a human-readable summary of the recommendation
   *
   * @generated from field: string description = 13;
   */
  description = "";

  /**
   * reasoning contains the reasons why this recommendation was generated
   *
   * @generated from field: repeated string reasoning = 14;
   */
  reasoning: string[] = [];

  /**
   * source identifies the data source (e.g., "aws", "kubecost", "azure-advisor")
   *
   * @generated from field: string source = 15;
   */
  source = "";

  /**
   * created_at is when the recommendation was generated (optional - may not be
   * available from all recommendation sources)
   *
   * @generated from field: optional google.protobuf.Timestamp created_at = 16;
   */
  createdAt?: Timestamp;

  /**
   * metadata contains additional provider-specific information
   *
   * @generated from field: map<string, string> metadata = 17;
   */
  metadata: { [key: string]: string } = {};

  /**
   * primary_reason is the main driver for the recommendation.
   *
   * @generated from field: finfocus.v1.RecommendationReason primary_reason = 18;
   */
  primaryReason = RecommendationReason.UNSPECIFIED;

  /**
   * secondary_reasons are contributing factors for the recommendation.
   *
   * @generated from field: repeated finfocus.v1.RecommendationReason secondary_reasons = 19;
   */
  secondaryReasons: RecommendationReason[] = [];

  constructor(data?: PartialMessage<Recommendation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.Recommendation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "category", kind: "enum", T: proto3.getEnumType(RecommendationCategory) },
    { no: 3, name: "action_type", kind: "enum", T: proto3.getEnumType(RecommendationActionType) },
    { no: 4, name: "resource", kind: "message", T: ResourceRecommendationInfo },
    { no: 5, name: "rightsize", kind: "message", T: RightsizeAction, oneof: "action_detail" },
    { no: 6, name: "terminate", kind: "message", T: TerminateAction, oneof: "action_detail" },
    { no: 7, name: "commitment", kind: "message", T: CommitmentAction, oneof: "action_detail" },
    { no: 8, name: "kubernetes", kind: "message", T: KubernetesAction, oneof: "action_detail" },
    { no: 9, name: "modify", kind: "message", T: ModifyAction, oneof: "action_detail" },
    { no: 10, name: "impact", kind: "message", T: RecommendationImpact },
    { no: 11, name: "priority", kind: "enum", T: proto3.getEnumType(RecommendationPriority) },
    { no: 12, name: "confidence_score", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 13, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "reasoning", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 15, name: "source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "created_at", kind: "message", T: Timestamp, opt: true },
    { no: 17, name: "metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 18, name: "primary_reason", kind: "enum", T: proto3.getEnumType(RecommendationReason) },
    { no: 19, name: "secondary_reasons", kind: "enum", T: proto3.getEnumType(RecommendationReason), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Recommendation {
    return new Recommendation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Recommendation {
    return new Recommendation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Recommendation {
    return new Recommendation().fromJsonString(jsonString, options);
  }

  static equals(a: Recommendation | PlainMessage<Recommendation> | undefined, b: Recommendation | PlainMessage<Recommendation> | undefined): boolean {
    return proto3.util.equals(Recommendation, a, b);
  }
}

/**
 * ResourceRecommendationInfo describes the resource targeted by a recommendation.
 * Named differently from existing ResourceDescriptor to avoid confusion.
 *
 * @generated from message finfocus.v1.ResourceRecommendationInfo
 */
export class ResourceRecommendationInfo extends Message<ResourceRecommendationInfo> {
  /**
   * id is the unique resource identifier
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * name is the human-readable resource name
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * provider is the cloud provider
   *
   * @generated from field: string provider = 3;
   */
  provider = "";

  /**
   * resource_type is the type of resource
   *
   * @generated from field: string resource_type = 4;
   */
  resourceType = "";

  /**
   * region is the deployment region
   *
   * @generated from field: string region = 5;
   */
  region = "";

  /**
   * sku is the SKU or instance type
   *
   * @generated from field: string sku = 6;
   */
  sku = "";

  /**
   * tags are resource labels/tags
   *
   * @generated from field: map<string, string> tags = 7;
   */
  tags: { [key: string]: string } = {};

  /**
   * utilization contains current resource utilization metrics
   *
   * @generated from field: finfocus.v1.ResourceUtilization utilization = 8;
   */
  utilization?: ResourceUtilization;

  constructor(data?: PartialMessage<ResourceRecommendationInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.ResourceRecommendationInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "provider", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "resource_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "sku", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "tags", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 8, name: "utilization", kind: "message", T: ResourceUtilization },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceRecommendationInfo {
    return new ResourceRecommendationInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceRecommendationInfo {
    return new ResourceRecommendationInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceRecommendationInfo {
    return new ResourceRecommendationInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceRecommendationInfo | PlainMessage<ResourceRecommendationInfo> | undefined, b: ResourceRecommendationInfo | PlainMessage<ResourceRecommendationInfo> | undefined): boolean {
    return proto3.util.equals(ResourceRecommendationInfo, a, b);
  }
}

/**
 * ResourceUtilization contains current utilization metrics for a resource.
 *
 * @generated from message finfocus.v1.ResourceUtilization
 */
export class ResourceUtilization extends Message<ResourceUtilization> {
  /**
   * cpu_percent is CPU utilization percentage
   *
   * @generated from field: double cpu_percent = 1;
   */
  cpuPercent = 0;

  /**
   * memory_percent is memory utilization percentage
   *
   * @generated from field: double memory_percent = 2;
   */
  memoryPercent = 0;

  /**
   * storage_percent is storage utilization percentage
   *
   * @generated from field: double storage_percent = 3;
   */
  storagePercent = 0;

  /**
   * network_in_mbps is network ingress in Mbps
   *
   * @generated from field: double network_in_mbps = 4;
   */
  networkInMbps = 0;

  /**
   * network_out_mbps is network egress in Mbps
   *
   * @generated from field: double network_out_mbps = 5;
   */
  networkOutMbps = 0;

  /**
   * custom_metrics contains provider-specific utilization metrics
   *
   * @generated from field: map<string, double> custom_metrics = 6;
   */
  customMetrics: { [key: string]: number } = {};

  constructor(data?: PartialMessage<ResourceUtilization>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.ResourceUtilization";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cpu_percent", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "memory_percent", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "storage_percent", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "network_in_mbps", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 5, name: "network_out_mbps", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 6, name: "custom_metrics", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 1 /* ScalarType.DOUBLE */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceUtilization {
    return new ResourceUtilization().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceUtilization {
    return new ResourceUtilization().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceUtilization {
    return new ResourceUtilization().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceUtilization | PlainMessage<ResourceUtilization> | undefined, b: ResourceUtilization | PlainMessage<ResourceUtilization> | undefined): boolean {
    return proto3.util.equals(ResourceUtilization, a, b);
  }
}

/**
 * RightsizeAction contains details for rightsizing recommendations.
 *
 * @generated from message finfocus.v1.RightsizeAction
 */
export class RightsizeAction extends Message<RightsizeAction> {
  /**
   * current_sku is the current SKU/size
   *
   * @generated from field: string current_sku = 1;
   */
  currentSku = "";

  /**
   * recommended_sku is the recommended SKU/size
   *
   * @generated from field: string recommended_sku = 2;
   */
  recommendedSku = "";

  /**
   * current_instance_type is the current instance type
   *
   * @generated from field: string current_instance_type = 3;
   */
  currentInstanceType = "";

  /**
   * recommended_instance_type is the recommended instance type
   *
   * @generated from field: string recommended_instance_type = 4;
   */
  recommendedInstanceType = "";

  /**
   * projected_utilization is the expected utilization after resize
   *
   * @generated from field: finfocus.v1.ResourceUtilization projected_utilization = 5;
   */
  projectedUtilization?: ResourceUtilization;

  constructor(data?: PartialMessage<RightsizeAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.RightsizeAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "current_sku", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "recommended_sku", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "current_instance_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "recommended_instance_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "projected_utilization", kind: "message", T: ResourceUtilization },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RightsizeAction {
    return new RightsizeAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RightsizeAction {
    return new RightsizeAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RightsizeAction {
    return new RightsizeAction().fromJsonString(jsonString, options);
  }

  static equals(a: RightsizeAction | PlainMessage<RightsizeAction> | undefined, b: RightsizeAction | PlainMessage<RightsizeAction> | undefined): boolean {
    return proto3.util.equals(RightsizeAction, a, b);
  }
}

/**
 * TerminateAction contains details for termination recommendations.
 *
 * @generated from message finfocus.v1.TerminateAction
 */
export class TerminateAction extends Message<TerminateAction> {
  /**
   * termination_reason explains why termination is recommended
   *
   * @generated from field: string termination_reason = 1;
   */
  terminationReason = "";

  /**
   * idle_days is the number of days the resource has been idle
   *
   * @generated from field: int32 idle_days = 2;
   */
  idleDays = 0;

  constructor(data?: PartialMessage<TerminateAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.TerminateAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "termination_reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "idle_days", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TerminateAction {
    return new TerminateAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TerminateAction {
    return new TerminateAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TerminateAction {
    return new TerminateAction().fromJsonString(jsonString, options);
  }

  static equals(a: TerminateAction | PlainMessage<TerminateAction> | undefined, b: TerminateAction | PlainMessage<TerminateAction> | undefined): boolean {
    return proto3.util.equals(TerminateAction, a, b);
  }
}

/**
 * CommitmentAction contains details for commitment purchase recommendations.
 *
 * @generated from message finfocus.v1.CommitmentAction
 */
export class CommitmentAction extends Message<CommitmentAction> {
  /**
   * commitment_type is the type of commitment (reserved_instance, savings_plan, cud)
   *
   * @generated from field: string commitment_type = 1;
   */
  commitmentType = "";

  /**
   * term is the commitment term (1_year, 3_year)
   *
   * @generated from field: string term = 2;
   */
  term = "";

  /**
   * payment_option is the payment option
   *
   * @generated from field: string payment_option = 3;
   */
  paymentOption = "";

  /**
   * recommended_quantity is the recommended purchase quantity
   *
   * @generated from field: double recommended_quantity = 4;
   */
  recommendedQuantity = 0;

  /**
   * scope is the commitment scope (account, region, etc.)
   *
   * @generated from field: string scope = 5;
   */
  scope = "";

  constructor(data?: PartialMessage<CommitmentAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.CommitmentAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "commitment_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "term", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "payment_option", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "recommended_quantity", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 5, name: "scope", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommitmentAction {
    return new CommitmentAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommitmentAction {
    return new CommitmentAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommitmentAction {
    return new CommitmentAction().fromJsonString(jsonString, options);
  }

  static equals(a: CommitmentAction | PlainMessage<CommitmentAction> | undefined, b: CommitmentAction | PlainMessage<CommitmentAction> | undefined): boolean {
    return proto3.util.equals(CommitmentAction, a, b);
  }
}

/**
 * KubernetesAction contains details for Kubernetes resource adjustments.
 *
 * @generated from message finfocus.v1.KubernetesAction
 */
export class KubernetesAction extends Message<KubernetesAction> {
  /**
   * cluster_id identifies the Kubernetes cluster
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId = "";

  /**
   * namespace is the Kubernetes namespace
   *
   * @generated from field: string namespace = 2;
   */
  namespace = "";

  /**
   * controller_kind is the controller type (Deployment, StatefulSet, etc.)
   *
   * @generated from field: string controller_kind = 3;
   */
  controllerKind = "";

  /**
   * controller_name is the name of the controller
   *
   * @generated from field: string controller_name = 4;
   */
  controllerName = "";

  /**
   * container_name is the name of the container
   *
   * @generated from field: string container_name = 5;
   */
  containerName = "";

  /**
   * current_requests are the current resource requests
   *
   * @generated from field: finfocus.v1.KubernetesResources current_requests = 6;
   */
  currentRequests?: KubernetesResources;

  /**
   * recommended_requests are the recommended resource requests
   *
   * @generated from field: finfocus.v1.KubernetesResources recommended_requests = 7;
   */
  recommendedRequests?: KubernetesResources;

  /**
   * current_limits are the current resource limits
   *
   * @generated from field: finfocus.v1.KubernetesResources current_limits = 8;
   */
  currentLimits?: KubernetesResources;

  /**
   * recommended_limits are the recommended resource limits
   *
   * @generated from field: finfocus.v1.KubernetesResources recommended_limits = 9;
   */
  recommendedLimits?: KubernetesResources;

  /**
   * algorithm is the recommendation algorithm used
   *
   * @generated from field: string algorithm = 10;
   */
  algorithm = "";

  constructor(data?: PartialMessage<KubernetesAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.KubernetesAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "controller_kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "controller_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "container_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "current_requests", kind: "message", T: KubernetesResources },
    { no: 7, name: "recommended_requests", kind: "message", T: KubernetesResources },
    { no: 8, name: "current_limits", kind: "message", T: KubernetesResources },
    { no: 9, name: "recommended_limits", kind: "message", T: KubernetesResources },
    { no: 10, name: "algorithm", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubernetesAction {
    return new KubernetesAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubernetesAction {
    return new KubernetesAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubernetesAction {
    return new KubernetesAction().fromJsonString(jsonString, options);
  }

  static equals(a: KubernetesAction | PlainMessage<KubernetesAction> | undefined, b: KubernetesAction | PlainMessage<KubernetesAction> | undefined): boolean {
    return proto3.util.equals(KubernetesAction, a, b);
  }
}

/**
 * KubernetesResources specifies CPU and memory for Kubernetes.
 *
 * @generated from message finfocus.v1.KubernetesResources
 */
export class KubernetesResources extends Message<KubernetesResources> {
  /**
   * cpu is the CPU specification (e.g., "100m", "2")
   *
   * @generated from field: string cpu = 1;
   */
  cpu = "";

  /**
   * memory is the memory specification (e.g., "256Mi", "2Gi")
   *
   * @generated from field: string memory = 2;
   */
  memory = "";

  constructor(data?: PartialMessage<KubernetesResources>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.KubernetesResources";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cpu", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "memory", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubernetesResources {
    return new KubernetesResources().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubernetesResources {
    return new KubernetesResources().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubernetesResources {
    return new KubernetesResources().fromJsonString(jsonString, options);
  }

  static equals(a: KubernetesResources | PlainMessage<KubernetesResources> | undefined, b: KubernetesResources | PlainMessage<KubernetesResources> | undefined): boolean {
    return proto3.util.equals(KubernetesResources, a, b);
  }
}

/**
 * ModifyAction contains details for generic modification recommendations.
 *
 * @generated from message finfocus.v1.ModifyAction
 */
export class ModifyAction extends Message<ModifyAction> {
  /**
   * modification_type describes the type of modification
   *
   * @generated from field: string modification_type = 1;
   */
  modificationType = "";

  /**
   * current_config is the current configuration
   *
   * @generated from field: map<string, string> current_config = 2;
   */
  currentConfig: { [key: string]: string } = {};

  /**
   * recommended_config is the recommended configuration
   *
   * @generated from field: map<string, string> recommended_config = 3;
   */
  recommendedConfig: { [key: string]: string } = {};

  constructor(data?: PartialMessage<ModifyAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.ModifyAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "modification_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "current_config", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 3, name: "recommended_config", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModifyAction {
    return new ModifyAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModifyAction {
    return new ModifyAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModifyAction {
    return new ModifyAction().fromJsonString(jsonString, options);
  }

  static equals(a: ModifyAction | PlainMessage<ModifyAction> | undefined, b: ModifyAction | PlainMessage<ModifyAction> | undefined): boolean {
    return proto3.util.equals(ModifyAction, a, b);
  }
}

/**
 * RecommendationImpact describes the financial impact of implementing a recommendation.
 *
 * @generated from message finfocus.v1.RecommendationImpact
 */
export class RecommendationImpact extends Message<RecommendationImpact> {
  /**
   * estimated_savings is the estimated cost savings
   *
   * @generated from field: double estimated_savings = 1;
   */
  estimatedSavings = 0;

  /**
   * currency is the ISO 4217 currency code
   *
   * @generated from field: string currency = 2;
   */
  currency = "";

  /**
   * projection_period is the time period for the projection
   *
   * @generated from field: string projection_period = 3;
   */
  projectionPeriod = "";

  /**
   * current_cost is the current cost
   *
   * @generated from field: double current_cost = 4;
   */
  currentCost = 0;

  /**
   * projected_cost is the projected cost after implementing the recommendation
   *
   * @generated from field: double projected_cost = 5;
   */
  projectedCost = 0;

  /**
   * savings_percentage is the savings as a percentage
   *
   * @generated from field: double savings_percentage = 6;
   */
  savingsPercentage = 0;

  /**
   * implementation_cost is the one-time cost to implement (if any)
   *
   * @generated from field: optional double implementation_cost = 7;
   */
  implementationCost?: number;

  /**
   * migration_effort_hours is the estimated effort in hours
   *
   * @generated from field: optional double migration_effort_hours = 8;
   */
  migrationEffortHours?: number;

  constructor(data?: PartialMessage<RecommendationImpact>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.RecommendationImpact";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "estimated_savings", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "currency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "projection_period", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "current_cost", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 5, name: "projected_cost", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 6, name: "savings_percentage", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 7, name: "implementation_cost", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 8, name: "migration_effort_hours", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecommendationImpact {
    return new RecommendationImpact().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecommendationImpact {
    return new RecommendationImpact().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecommendationImpact {
    return new RecommendationImpact().fromJsonString(jsonString, options);
  }

  static equals(a: RecommendationImpact | PlainMessage<RecommendationImpact> | undefined, b: RecommendationImpact | PlainMessage<RecommendationImpact> | undefined): boolean {
    return proto3.util.equals(RecommendationImpact, a, b);
  }
}

/**
 * RecommendationSummary provides aggregated statistics for a page of recommendations.
 *
 * @generated from message finfocus.v1.RecommendationSummary
 */
export class RecommendationSummary extends Message<RecommendationSummary> {
  /**
   * total_recommendations is the count of recommendations in this page
   *
   * @generated from field: int32 total_recommendations = 1;
   */
  totalRecommendations = 0;

  /**
   * total_estimated_savings is the total savings for recommendations in this page
   *
   * @generated from field: double total_estimated_savings = 2;
   */
  totalEstimatedSavings = 0;

  /**
   * currency is the ISO 4217 currency code for savings
   *
   * @generated from field: string currency = 3;
   */
  currency = "";

  /**
   * projection_period matches GetRecommendationsRequest.projection_period
   * (e.g., "daily", "monthly", "annual"). Servers apply a default when omitted.
   *
   * @generated from field: string projection_period = 4;
   */
  projectionPeriod = "";

  /**
   * count_by_category maps category name to count
   *
   * @generated from field: map<string, int32> count_by_category = 5;
   */
  countByCategory: { [key: string]: number } = {};

  /**
   * savings_by_category maps category name to total savings
   *
   * @generated from field: map<string, double> savings_by_category = 6;
   */
  savingsByCategory: { [key: string]: number } = {};

  /**
   * count_by_action_type maps action type name to count
   *
   * @generated from field: map<string, int32> count_by_action_type = 7;
   */
  countByActionType: { [key: string]: number } = {};

  /**
   * savings_by_action_type maps action type name to total savings
   *
   * @generated from field: map<string, double> savings_by_action_type = 8;
   */
  savingsByActionType: { [key: string]: number } = {};

  constructor(data?: PartialMessage<RecommendationSummary>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.RecommendationSummary";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "total_recommendations", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "total_estimated_savings", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "currency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "projection_period", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "count_by_category", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 5 /* ScalarType.INT32 */} },
    { no: 6, name: "savings_by_category", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 1 /* ScalarType.DOUBLE */} },
    { no: 7, name: "count_by_action_type", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 5 /* ScalarType.INT32 */} },
    { no: 8, name: "savings_by_action_type", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 1 /* ScalarType.DOUBLE */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecommendationSummary {
    return new RecommendationSummary().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecommendationSummary {
    return new RecommendationSummary().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecommendationSummary {
    return new RecommendationSummary().fromJsonString(jsonString, options);
  }

  static equals(a: RecommendationSummary | PlainMessage<RecommendationSummary> | undefined, b: RecommendationSummary | PlainMessage<RecommendationSummary> | undefined): boolean {
    return proto3.util.equals(RecommendationSummary, a, b);
  }
}

/**
 * DismissRecommendationRequest contains parameters for dismissing a recommendation.
 *
 * @generated from message finfocus.v1.DismissRecommendationRequest
 */
export class DismissRecommendationRequest extends Message<DismissRecommendationRequest> {
  /**
   * recommendation_id is the unique identifier of the recommendation to dismiss.
   * Required field.
   *
   * @generated from field: string recommendation_id = 1;
   */
  recommendationId = "";

  /**
   * reason specifies why the recommendation is being dismissed.
   * Optional but recommended for audit purposes.
   *
   * @generated from field: finfocus.v1.DismissalReason reason = 2;
   */
  reason = DismissalReason.UNSPECIFIED;

  /**
   * custom_reason provides free-form text when reason is OTHER or
   * to supplement the structured reason. Max 500 characters.
   *
   * @generated from field: string custom_reason = 3;
   */
  customReason = "";

  /**
   * expires_at specifies when the dismissal should expire and the
   * recommendation should reappear. If not set, dismissal is permanent
   * (or until the recommendation naturally expires).
   *
   * @generated from field: optional google.protobuf.Timestamp expires_at = 4;
   */
  expiresAt?: Timestamp;

  /**
   * dismissed_by identifies who dismissed the recommendation (e.g., user ID, email).
   * Optional, used for audit purposes.
   *
   * @generated from field: string dismissed_by = 5;
   */
  dismissedBy = "";

  constructor(data?: PartialMessage<DismissRecommendationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.DismissRecommendationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "recommendation_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "reason", kind: "enum", T: proto3.getEnumType(DismissalReason) },
    { no: 3, name: "custom_reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "expires_at", kind: "message", T: Timestamp, opt: true },
    { no: 5, name: "dismissed_by", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DismissRecommendationRequest {
    return new DismissRecommendationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DismissRecommendationRequest {
    return new DismissRecommendationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DismissRecommendationRequest {
    return new DismissRecommendationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DismissRecommendationRequest | PlainMessage<DismissRecommendationRequest> | undefined, b: DismissRecommendationRequest | PlainMessage<DismissRecommendationRequest> | undefined): boolean {
    return proto3.util.equals(DismissRecommendationRequest, a, b);
  }
}

/**
 * DismissRecommendationResponse confirms the dismissal.
 *
 * @generated from message finfocus.v1.DismissRecommendationResponse
 */
export class DismissRecommendationResponse extends Message<DismissRecommendationResponse> {
  /**
   * success indicates if the dismissal was successful.
   *
   * @generated from field: bool success = 1;
   */
  success = false;

  /**
   * message provides additional context (e.g., confirmation or error details).
   *
   * @generated from field: string message = 2;
   */
  message = "";

  /**
   * dismissed_at is the timestamp when the dismissal was recorded.
   *
   * @generated from field: google.protobuf.Timestamp dismissed_at = 3;
   */
  dismissedAt?: Timestamp;

  /**
   * expires_at echoes back when the dismissal will expire (if set).
   *
   * @generated from field: optional google.protobuf.Timestamp expires_at = 4;
   */
  expiresAt?: Timestamp;

  /**
   * recommendation_id echoes back the dismissed recommendation ID for confirmation.
   *
   * @generated from field: string recommendation_id = 5;
   */
  recommendationId = "";

  constructor(data?: PartialMessage<DismissRecommendationResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.DismissRecommendationResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "dismissed_at", kind: "message", T: Timestamp },
    { no: 4, name: "expires_at", kind: "message", T: Timestamp, opt: true },
    { no: 5, name: "recommendation_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DismissRecommendationResponse {
    return new DismissRecommendationResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DismissRecommendationResponse {
    return new DismissRecommendationResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DismissRecommendationResponse {
    return new DismissRecommendationResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DismissRecommendationResponse | PlainMessage<DismissRecommendationResponse> | undefined, b: DismissRecommendationResponse | PlainMessage<DismissRecommendationResponse> | undefined): boolean {
    return proto3.util.equals(DismissRecommendationResponse, a, b);
  }
}

/**
 * GetPluginInfoRequest is used to request plugin metadata.
 * Currently empty but may be extended in the future.
 *
 * @generated from message finfocus.v1.GetPluginInfoRequest
 */
export class GetPluginInfoRequest extends Message<GetPluginInfoRequest> {
  constructor(data?: PartialMessage<GetPluginInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.GetPluginInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPluginInfoRequest {
    return new GetPluginInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPluginInfoRequest {
    return new GetPluginInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPluginInfoRequest {
    return new GetPluginInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetPluginInfoRequest | PlainMessage<GetPluginInfoRequest> | undefined, b: GetPluginInfoRequest | PlainMessage<GetPluginInfoRequest> | undefined): boolean {
    return proto3.util.equals(GetPluginInfoRequest, a, b);
  }
}

/**
 * GetPluginInfoResponse contains metadata about the plugin for compatibility
 * verification, diagnostics, and graceful degradation handling.
 *
 * @generated from message finfocus.v1.GetPluginInfoResponse
 */
export class GetPluginInfoResponse extends Message<GetPluginInfoResponse> {
  /**
   * name is the display name of the plugin (e.g., "aws-cost-plugin").
   * Required field - must be non-empty.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * version is the semantic version of the plugin implementation (e.g., "v1.2.0").
   * Required field - must be non-empty.
   *
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * spec_version is the version of the finfocus-spec protocol the plugin was
   * compiled against (e.g., "v0.4.11"). Must be a valid SemVer string.
   * Required field - used for compatibility verification.
   *
   * @generated from field: string spec_version = 3;
   */
  specVersion = "";

  /**
   * providers lists the cloud providers supported by this plugin (e.g., ["aws"]).
   * At least one provider should be listed for functional plugins.
   *
   * @generated from field: repeated string providers = 4;
   */
  providers: string[] = [];

  /**
   * metadata contains optional key-value pairs for additional information
   * such as build hash, commit ID, or plugin-specific configuration.
   * Free-form; no key restrictions or size limits enforced by SDK.
   *
   * @generated from field: map<string, string> metadata = 5;
   */
  metadata: { [key: string]: string } = {};

  /**
   * Explicit capability declarations using type-safe enum
   *
   * @generated from field: repeated finfocus.v1.PluginCapability capabilities = 6;
   */
  capabilities: PluginCapability[] = [];

  constructor(data?: PartialMessage<GetPluginInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.GetPluginInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "spec_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "providers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 6, name: "capabilities", kind: "enum", T: proto3.getEnumType(PluginCapability), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPluginInfoResponse {
    return new GetPluginInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPluginInfoResponse {
    return new GetPluginInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPluginInfoResponse {
    return new GetPluginInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetPluginInfoResponse | PlainMessage<GetPluginInfoResponse> | undefined, b: GetPluginInfoResponse | PlainMessage<GetPluginInfoResponse> | undefined): boolean {
    return proto3.util.equals(GetPluginInfoResponse, a, b);
  }
}

/**
 * FieldMapping represents the support status for a single FOCUS field.
 * Used in DryRunResponse to report which fields a plugin would populate
 * for a given resource type.
 *
 * @generated from message finfocus.v1.FieldMapping
 */
export class FieldMapping extends Message<FieldMapping> {
  /**
   * field_name is the FOCUS field identifier (e.g., "service_category", "billed_cost").
   * Must match a field name in FocusCostRecord message.
   * Required field.
   *
   * @generated from field: string field_name = 1;
   */
  fieldName = "";

  /**
   * support_status indicates how this field is supported for the queried resource type.
   * See FieldSupportStatus enum for detailed semantics.
   * Required field - should never be UNSPECIFIED in well-formed responses.
   *
   * @generated from field: finfocus.v1.FieldSupportStatus support_status = 2;
   */
  supportStatus = FieldSupportStatus.UNSPECIFIED;

  /**
   * condition_description provides human-readable explanation when status is
   * CONDITIONAL or DYNAMIC. Optional for SUPPORTED/UNSUPPORTED status.
   * Example: "Only populated for regional resources in multi-AZ providers"
   * Maximum recommended length: 256 characters.
   *
   * @generated from field: string condition_description = 3;
   */
  conditionDescription = "";

  /**
   * expected_type indicates the data type of the field value.
   * Values: "string", "double", "timestamp", "enum", "map", "bool"
   * Optional but recommended for documentation purposes.
   *
   * @generated from field: string expected_type = 4;
   */
  expectedType = "";

  constructor(data?: PartialMessage<FieldMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.FieldMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "support_status", kind: "enum", T: proto3.getEnumType(FieldSupportStatus) },
    { no: 3, name: "condition_description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "expected_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldMapping {
    return new FieldMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldMapping {
    return new FieldMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldMapping {
    return new FieldMapping().fromJsonString(jsonString, options);
  }

  static equals(a: FieldMapping | PlainMessage<FieldMapping> | undefined, b: FieldMapping | PlainMessage<FieldMapping> | undefined): boolean {
    return proto3.util.equals(FieldMapping, a, b);
  }
}

/**
 * DryRunRequest contains parameters for querying plugin field mapping capabilities.
 * Sent to the DryRun RPC for standalone capability discovery.
 *
 * @generated from message finfocus.v1.DryRunRequest
 */
export class DryRunRequest extends Message<DryRunRequest> {
  /**
   * resource contains the resource descriptor to query field mappings for.
   * Required. Must have valid provider and resource_type fields.
   * Region, SKU, and tags are optional but may influence field support status.
   *
   * @generated from field: finfocus.v1.ResourceDescriptor resource = 1;
   */
  resource?: ResourceDescriptor;

  /**
   * simulation_parameters provides optional key-value pairs to simulate
   * different scenarios (e.g., {"region": "us-west-2"} to see region-specific behavior).
   * Unknown keys are ignored by plugins.
   * Maximum recommended size: 20 key-value pairs.
   *
   * @generated from field: map<string, string> simulation_parameters = 2;
   */
  simulationParameters: { [key: string]: string } = {};

  constructor(data?: PartialMessage<DryRunRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.DryRunRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource", kind: "message", T: ResourceDescriptor },
    { no: 2, name: "simulation_parameters", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DryRunRequest {
    return new DryRunRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DryRunRequest {
    return new DryRunRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DryRunRequest {
    return new DryRunRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DryRunRequest | PlainMessage<DryRunRequest> | undefined, b: DryRunRequest | PlainMessage<DryRunRequest> | undefined): boolean {
    return proto3.util.equals(DryRunRequest, a, b);
  }
}

/**
 * DryRunResponse contains the field mapping information returned by a plugin.
 * Includes per-field support status and configuration validation results.
 *
 * Response time requirement: <100ms (no external API calls should be made).
 * This is a synchronous, stateless introspection operation.
 *
 * @generated from message finfocus.v1.DryRunResponse
 */
export class DryRunResponse extends Message<DryRunResponse> {
  /**
   * field_mappings contains the support status for each known FOCUS field.
   * Should include entries for all ~50-66 FocusCostRecord fields.
   * Order is not significant.
   *
   * @generated from field: repeated finfocus.v1.FieldMapping field_mappings = 1;
   */
  fieldMappings: FieldMapping[] = [];

  /**
   * configuration_valid indicates whether the plugin configuration is valid.
   * When false, configuration_errors contains the error details.
   * A plugin with valid configuration may still not support a resource type.
   *
   * @generated from field: bool configuration_valid = 2;
   */
  configurationValid = false;

  /**
   * configuration_errors contains human-readable error messages when
   * configuration_valid is false. Empty when configuration is valid.
   * Examples: "Missing API key", "Invalid endpoint URL"
   *
   * @generated from field: repeated string configuration_errors = 3;
   */
  configurationErrors: string[] = [];

  /**
   * resource_type_supported indicates whether the queried resource type
   * is supported by this plugin. When false, field_mappings may be empty
   * or contain only UNSUPPORTED entries.
   *
   * @generated from field: bool resource_type_supported = 4;
   */
  resourceTypeSupported = false;

  constructor(data?: PartialMessage<DryRunResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "finfocus.v1.DryRunResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field_mappings", kind: "message", T: FieldMapping, repeated: true },
    { no: 2, name: "configuration_valid", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "configuration_errors", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "resource_type_supported", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DryRunResponse {
    return new DryRunResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DryRunResponse {
    return new DryRunResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DryRunResponse {
    return new DryRunResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DryRunResponse | PlainMessage<DryRunResponse> | undefined, b: DryRunResponse | PlainMessage<DryRunResponse> | undefined): boolean {
    return proto3.util.equals(DryRunResponse, a, b);
  }
}

