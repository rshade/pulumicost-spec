// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             (unknown)
// source: finfocus/v1/costsource.proto

package pbc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CostSourceService_Name_FullMethodName                  = "/finfocus.v1.CostSourceService/Name"
	CostSourceService_Supports_FullMethodName              = "/finfocus.v1.CostSourceService/Supports"
	CostSourceService_GetActualCost_FullMethodName         = "/finfocus.v1.CostSourceService/GetActualCost"
	CostSourceService_GetProjectedCost_FullMethodName      = "/finfocus.v1.CostSourceService/GetProjectedCost"
	CostSourceService_GetPricingSpec_FullMethodName        = "/finfocus.v1.CostSourceService/GetPricingSpec"
	CostSourceService_EstimateCost_FullMethodName          = "/finfocus.v1.CostSourceService/EstimateCost"
	CostSourceService_GetRecommendations_FullMethodName    = "/finfocus.v1.CostSourceService/GetRecommendations"
	CostSourceService_DismissRecommendation_FullMethodName = "/finfocus.v1.CostSourceService/DismissRecommendation"
	CostSourceService_GetBudgets_FullMethodName            = "/finfocus.v1.CostSourceService/GetBudgets"
	CostSourceService_GetPluginInfo_FullMethodName         = "/finfocus.v1.CostSourceService/GetPluginInfo"
	CostSourceService_DryRun_FullMethodName                = "/finfocus.v1.CostSourceService/DryRun"
)

// CostSourceServiceClient is the client API for CostSourceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// CostSourceService provides gRPC interface for cost source plugins to implement.
// This service defines the contract for retrieving actual costs, projected costs,
// and pricing specifications from various cost data sources.
type CostSourceServiceClient interface {
	// Name returns the display name of the cost source plugin.
	Name(ctx context.Context, in *NameRequest, opts ...grpc.CallOption) (*NameResponse, error)
	// Supports checks if the cost source supports pricing for a given resource type.
	Supports(ctx context.Context, in *SupportsRequest, opts ...grpc.CallOption) (*SupportsResponse, error)
	// GetActualCost retrieves historical cost data for a specific resource.
	GetActualCost(ctx context.Context, in *GetActualCostRequest, opts ...grpc.CallOption) (*GetActualCostResponse, error)
	// GetProjectedCost calculates projected cost information for a resource.
	GetProjectedCost(ctx context.Context, in *GetProjectedCostRequest, opts ...grpc.CallOption) (*GetProjectedCostResponse, error)
	// GetPricingSpec returns detailed pricing specification for a resource type.
	GetPricingSpec(ctx context.Context, in *GetPricingSpecRequest, opts ...grpc.CallOption) (*GetPricingSpecResponse, error)
	// EstimateCost returns an estimated monthly cost for a resource based on
	// its type and configuration attributes. This enables proactive cost
	// planning before resource deployment.
	//
	// The method is idempotent - identical inputs always produce identical
	// outputs (deterministic pricing). Response time should be <500ms for
	// standard resource types.
	//
	// Error cases:
	//   - InvalidArgument: Invalid resource_type format or missing required attributes
	//   - NotFound: Unsupported resource_type for this plugin
	//   - Unavailable: Pricing source temporarily unavailable
	EstimateCost(ctx context.Context, in *EstimateCostRequest, opts ...grpc.CallOption) (*EstimateCostResponse, error)
	// GetRecommendations retrieves cost optimization recommendations.
	// Returns recommendations from the underlying cost management service
	// (AWS Cost Explorer, Kubecost, Azure Advisor, GCP Recommender, etc.).
	//
	// Plugins that do not support recommendations return an empty list.
	// This RPC is optional - plugins implement RecommendationsProvider interface.
	//
	// Error cases:
	//   - InvalidArgument: Invalid filter criteria or pagination token
	//   - Unavailable: Backend recommendation service unavailable
	GetRecommendations(ctx context.Context, in *GetRecommendationsRequest, opts ...grpc.CallOption) (*GetRecommendationsResponse, error)
	// DismissRecommendation marks a recommendation as dismissed/ignored.
	// This is an optional RPC - plugins that support stateful recommendation
	// management can implement this to persist dismissal state. Plugins that
	// don't support dismissals should return Unimplemented.
	//
	// When a recommendation is dismissed:
	//   - It should not appear in future GetRecommendations responses
	//   - The dismissal may expire after a configurable period
	//   - Users can optionally provide a reason for the dismissal
	//
	// Error cases:
	//   - InvalidArgument: Empty recommendation_id or invalid expiration
	//   - NotFound: Recommendation ID does not exist
	//   - Unimplemented: Plugin does not support recommendation dismissal
	DismissRecommendation(ctx context.Context, in *DismissRecommendationRequest, opts ...grpc.CallOption) (*DismissRecommendationResponse, error)
	// GetBudgets returns budget information from the cost management service.
	// This enables unified budget visibility across cloud providers (AWS, GCP, Azure, etc.).
	//
	// The method supports optional filtering by provider, region, resource type, and tags.
	// Use include_status=false for faster responses when current spend data isn't needed.
	// Response time should be <5 seconds for typical budget queries (100-1000 budgets).
	//
	// This is an optional RPC - plugins may return Unimplemented if budget functionality
	// is not supported by the underlying cost management service.
	//
	// Error cases:
	//   - InvalidArgument: Invalid filter criteria or malformed request
	//   - Unavailable: Budget service temporarily unavailable
	//   - Unimplemented: Plugin does not support budget functionality
	GetBudgets(ctx context.Context, in *GetBudgetsRequest, opts ...grpc.CallOption) (*GetBudgetsResponse, error)
	// GetPluginInfo returns metadata about the plugin for compatibility verification,
	// diagnostics, and graceful degradation handling.
	//
	// This RPC enables the core system to:
	//  1. Verify plugin compatibility by checking spec_version against supported ranges
	//  2. Display plugin information in diagnostic tools (plugin list commands)
	//  3. Handle legacy plugins gracefully (Unimplemented error = legacy plugin)
	//
	// The SDK provides a default implementation that returns compile-time constants.
	// Plugins may override this to provide dynamic metadata if needed.
	//
	// Response time should be <100ms (metadata retrieval should be instant).
	//
	// Error cases:
	//   - Unimplemented: Plugin is too old to support this RPC (legacy plugin)
	//   - Internal: Plugin failed to retrieve its own metadata (unexpected)
	//
	// Client-side error handling example (Go):
	//
	//	resp, err := client.GetPluginInfo(ctx, &GetPluginInfoRequest{})
	//	if err != nil {
	//	    if status.Code(err) == codes.Unimplemented {
	//	        // Legacy plugin - use fallback values
	//	        log.Info("Plugin does not implement GetPluginInfo")
	//	        return &PluginMetadata{Name: "unknown", Version: "unknown"}
	//	    }
	//	    return nil, fmt.Errorf("GetPluginInfo failed: %w", err)
	//	}
	//	return &PluginMetadata{
	//	    Name:        resp.GetName(),
	//	    Version:     resp.GetVersion(),
	//	    SpecVersion: resp.GetSpecVersion(),
	//	}
	GetPluginInfo(ctx context.Context, in *GetPluginInfoRequest, opts ...grpc.CallOption) (*GetPluginInfoResponse, error)
	// DryRun returns field mapping information for a resource type without
	// performing actual cost data retrieval. Useful for debugging plugin
	// configurations and comparing plugin capabilities.
	//
	// This RPC is optional - plugins that do not support dry-run introspection
	// should return Unimplemented. Check SupportsResponse.capabilities["dry_run"]
	// to detect support before calling.
	//
	// Response time requirement: <100ms (no external network calls).
	// The response should be generated entirely from local configuration/logic.
	//
	// Error cases:
	//   - InvalidArgument: Invalid resource descriptor (empty provider/resource_type)
	//   - Unimplemented: Plugin does not support dry-run introspection
	//   - Internal: Unexpected error during introspection
	//
	// Client-side error handling example (Go):
	//
	//	resp, err := client.DryRun(ctx, &DryRunRequest{...})
	//	if err != nil {
	//	    if status.Code(err) == codes.Unimplemented {
	//	        log.Info("Plugin does not implement DryRun RPC")
	//	        // Fall back to inferring capabilities from Supports RPC
	//	        return nil
	//	    }
	//	    return nil, fmt.Errorf("DryRun failed: %w", err)
	//	}
	//	// Process field mappings
	//	for _, fm := range resp.GetFieldMappings() {
	//	    log.Printf("%s: %v", fm.GetFieldName(), fm.GetSupportStatus())
	//	}
	DryRun(ctx context.Context, in *DryRunRequest, opts ...grpc.CallOption) (*DryRunResponse, error)
}

type costSourceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCostSourceServiceClient(cc grpc.ClientConnInterface) CostSourceServiceClient {
	return &costSourceServiceClient{cc}
}

func (c *costSourceServiceClient) Name(ctx context.Context, in *NameRequest, opts ...grpc.CallOption) (*NameResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NameResponse)
	err := c.cc.Invoke(ctx, CostSourceService_Name_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *costSourceServiceClient) Supports(ctx context.Context, in *SupportsRequest, opts ...grpc.CallOption) (*SupportsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SupportsResponse)
	err := c.cc.Invoke(ctx, CostSourceService_Supports_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *costSourceServiceClient) GetActualCost(ctx context.Context, in *GetActualCostRequest, opts ...grpc.CallOption) (*GetActualCostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetActualCostResponse)
	err := c.cc.Invoke(ctx, CostSourceService_GetActualCost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *costSourceServiceClient) GetProjectedCost(ctx context.Context, in *GetProjectedCostRequest, opts ...grpc.CallOption) (*GetProjectedCostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProjectedCostResponse)
	err := c.cc.Invoke(ctx, CostSourceService_GetProjectedCost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *costSourceServiceClient) GetPricingSpec(ctx context.Context, in *GetPricingSpecRequest, opts ...grpc.CallOption) (*GetPricingSpecResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPricingSpecResponse)
	err := c.cc.Invoke(ctx, CostSourceService_GetPricingSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *costSourceServiceClient) EstimateCost(ctx context.Context, in *EstimateCostRequest, opts ...grpc.CallOption) (*EstimateCostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EstimateCostResponse)
	err := c.cc.Invoke(ctx, CostSourceService_EstimateCost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *costSourceServiceClient) GetRecommendations(ctx context.Context, in *GetRecommendationsRequest, opts ...grpc.CallOption) (*GetRecommendationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRecommendationsResponse)
	err := c.cc.Invoke(ctx, CostSourceService_GetRecommendations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *costSourceServiceClient) DismissRecommendation(ctx context.Context, in *DismissRecommendationRequest, opts ...grpc.CallOption) (*DismissRecommendationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DismissRecommendationResponse)
	err := c.cc.Invoke(ctx, CostSourceService_DismissRecommendation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *costSourceServiceClient) GetBudgets(ctx context.Context, in *GetBudgetsRequest, opts ...grpc.CallOption) (*GetBudgetsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBudgetsResponse)
	err := c.cc.Invoke(ctx, CostSourceService_GetBudgets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *costSourceServiceClient) GetPluginInfo(ctx context.Context, in *GetPluginInfoRequest, opts ...grpc.CallOption) (*GetPluginInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPluginInfoResponse)
	err := c.cc.Invoke(ctx, CostSourceService_GetPluginInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *costSourceServiceClient) DryRun(ctx context.Context, in *DryRunRequest, opts ...grpc.CallOption) (*DryRunResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DryRunResponse)
	err := c.cc.Invoke(ctx, CostSourceService_DryRun_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CostSourceServiceServer is the server API for CostSourceService service.
// All implementations must embed UnimplementedCostSourceServiceServer
// for forward compatibility.
//
// CostSourceService provides gRPC interface for cost source plugins to implement.
// This service defines the contract for retrieving actual costs, projected costs,
// and pricing specifications from various cost data sources.
type CostSourceServiceServer interface {
	// Name returns the display name of the cost source plugin.
	Name(context.Context, *NameRequest) (*NameResponse, error)
	// Supports checks if the cost source supports pricing for a given resource type.
	Supports(context.Context, *SupportsRequest) (*SupportsResponse, error)
	// GetActualCost retrieves historical cost data for a specific resource.
	GetActualCost(context.Context, *GetActualCostRequest) (*GetActualCostResponse, error)
	// GetProjectedCost calculates projected cost information for a resource.
	GetProjectedCost(context.Context, *GetProjectedCostRequest) (*GetProjectedCostResponse, error)
	// GetPricingSpec returns detailed pricing specification for a resource type.
	GetPricingSpec(context.Context, *GetPricingSpecRequest) (*GetPricingSpecResponse, error)
	// EstimateCost returns an estimated monthly cost for a resource based on
	// its type and configuration attributes. This enables proactive cost
	// planning before resource deployment.
	//
	// The method is idempotent - identical inputs always produce identical
	// outputs (deterministic pricing). Response time should be <500ms for
	// standard resource types.
	//
	// Error cases:
	//   - InvalidArgument: Invalid resource_type format or missing required attributes
	//   - NotFound: Unsupported resource_type for this plugin
	//   - Unavailable: Pricing source temporarily unavailable
	EstimateCost(context.Context, *EstimateCostRequest) (*EstimateCostResponse, error)
	// GetRecommendations retrieves cost optimization recommendations.
	// Returns recommendations from the underlying cost management service
	// (AWS Cost Explorer, Kubecost, Azure Advisor, GCP Recommender, etc.).
	//
	// Plugins that do not support recommendations return an empty list.
	// This RPC is optional - plugins implement RecommendationsProvider interface.
	//
	// Error cases:
	//   - InvalidArgument: Invalid filter criteria or pagination token
	//   - Unavailable: Backend recommendation service unavailable
	GetRecommendations(context.Context, *GetRecommendationsRequest) (*GetRecommendationsResponse, error)
	// DismissRecommendation marks a recommendation as dismissed/ignored.
	// This is an optional RPC - plugins that support stateful recommendation
	// management can implement this to persist dismissal state. Plugins that
	// don't support dismissals should return Unimplemented.
	//
	// When a recommendation is dismissed:
	//   - It should not appear in future GetRecommendations responses
	//   - The dismissal may expire after a configurable period
	//   - Users can optionally provide a reason for the dismissal
	//
	// Error cases:
	//   - InvalidArgument: Empty recommendation_id or invalid expiration
	//   - NotFound: Recommendation ID does not exist
	//   - Unimplemented: Plugin does not support recommendation dismissal
	DismissRecommendation(context.Context, *DismissRecommendationRequest) (*DismissRecommendationResponse, error)
	// GetBudgets returns budget information from the cost management service.
	// This enables unified budget visibility across cloud providers (AWS, GCP, Azure, etc.).
	//
	// The method supports optional filtering by provider, region, resource type, and tags.
	// Use include_status=false for faster responses when current spend data isn't needed.
	// Response time should be <5 seconds for typical budget queries (100-1000 budgets).
	//
	// This is an optional RPC - plugins may return Unimplemented if budget functionality
	// is not supported by the underlying cost management service.
	//
	// Error cases:
	//   - InvalidArgument: Invalid filter criteria or malformed request
	//   - Unavailable: Budget service temporarily unavailable
	//   - Unimplemented: Plugin does not support budget functionality
	GetBudgets(context.Context, *GetBudgetsRequest) (*GetBudgetsResponse, error)
	// GetPluginInfo returns metadata about the plugin for compatibility verification,
	// diagnostics, and graceful degradation handling.
	//
	// This RPC enables the core system to:
	//  1. Verify plugin compatibility by checking spec_version against supported ranges
	//  2. Display plugin information in diagnostic tools (plugin list commands)
	//  3. Handle legacy plugins gracefully (Unimplemented error = legacy plugin)
	//
	// The SDK provides a default implementation that returns compile-time constants.
	// Plugins may override this to provide dynamic metadata if needed.
	//
	// Response time should be <100ms (metadata retrieval should be instant).
	//
	// Error cases:
	//   - Unimplemented: Plugin is too old to support this RPC (legacy plugin)
	//   - Internal: Plugin failed to retrieve its own metadata (unexpected)
	//
	// Client-side error handling example (Go):
	//
	//	resp, err := client.GetPluginInfo(ctx, &GetPluginInfoRequest{})
	//	if err != nil {
	//	    if status.Code(err) == codes.Unimplemented {
	//	        // Legacy plugin - use fallback values
	//	        log.Info("Plugin does not implement GetPluginInfo")
	//	        return &PluginMetadata{Name: "unknown", Version: "unknown"}
	//	    }
	//	    return nil, fmt.Errorf("GetPluginInfo failed: %w", err)
	//	}
	//	return &PluginMetadata{
	//	    Name:        resp.GetName(),
	//	    Version:     resp.GetVersion(),
	//	    SpecVersion: resp.GetSpecVersion(),
	//	}
	GetPluginInfo(context.Context, *GetPluginInfoRequest) (*GetPluginInfoResponse, error)
	// DryRun returns field mapping information for a resource type without
	// performing actual cost data retrieval. Useful for debugging plugin
	// configurations and comparing plugin capabilities.
	//
	// This RPC is optional - plugins that do not support dry-run introspection
	// should return Unimplemented. Check SupportsResponse.capabilities["dry_run"]
	// to detect support before calling.
	//
	// Response time requirement: <100ms (no external network calls).
	// The response should be generated entirely from local configuration/logic.
	//
	// Error cases:
	//   - InvalidArgument: Invalid resource descriptor (empty provider/resource_type)
	//   - Unimplemented: Plugin does not support dry-run introspection
	//   - Internal: Unexpected error during introspection
	//
	// Client-side error handling example (Go):
	//
	//	resp, err := client.DryRun(ctx, &DryRunRequest{...})
	//	if err != nil {
	//	    if status.Code(err) == codes.Unimplemented {
	//	        log.Info("Plugin does not implement DryRun RPC")
	//	        // Fall back to inferring capabilities from Supports RPC
	//	        return nil
	//	    }
	//	    return nil, fmt.Errorf("DryRun failed: %w", err)
	//	}
	//	// Process field mappings
	//	for _, fm := range resp.GetFieldMappings() {
	//	    log.Printf("%s: %v", fm.GetFieldName(), fm.GetSupportStatus())
	//	}
	DryRun(context.Context, *DryRunRequest) (*DryRunResponse, error)
	mustEmbedUnimplementedCostSourceServiceServer()
}

// UnimplementedCostSourceServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCostSourceServiceServer struct{}

func (UnimplementedCostSourceServiceServer) Name(context.Context, *NameRequest) (*NameResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Name not implemented")
}
func (UnimplementedCostSourceServiceServer) Supports(context.Context, *SupportsRequest) (*SupportsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Supports not implemented")
}
func (UnimplementedCostSourceServiceServer) GetActualCost(context.Context, *GetActualCostRequest) (*GetActualCostResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetActualCost not implemented")
}
func (UnimplementedCostSourceServiceServer) GetProjectedCost(context.Context, *GetProjectedCostRequest) (*GetProjectedCostResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetProjectedCost not implemented")
}
func (UnimplementedCostSourceServiceServer) GetPricingSpec(context.Context, *GetPricingSpecRequest) (*GetPricingSpecResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPricingSpec not implemented")
}
func (UnimplementedCostSourceServiceServer) EstimateCost(context.Context, *EstimateCostRequest) (*EstimateCostResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EstimateCost not implemented")
}
func (UnimplementedCostSourceServiceServer) GetRecommendations(context.Context, *GetRecommendationsRequest) (*GetRecommendationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRecommendations not implemented")
}
func (UnimplementedCostSourceServiceServer) DismissRecommendation(context.Context, *DismissRecommendationRequest) (*DismissRecommendationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DismissRecommendation not implemented")
}
func (UnimplementedCostSourceServiceServer) GetBudgets(context.Context, *GetBudgetsRequest) (*GetBudgetsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBudgets not implemented")
}
func (UnimplementedCostSourceServiceServer) GetPluginInfo(context.Context, *GetPluginInfoRequest) (*GetPluginInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPluginInfo not implemented")
}
func (UnimplementedCostSourceServiceServer) DryRun(context.Context, *DryRunRequest) (*DryRunResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DryRun not implemented")
}
func (UnimplementedCostSourceServiceServer) mustEmbedUnimplementedCostSourceServiceServer() {}
func (UnimplementedCostSourceServiceServer) testEmbeddedByValue()                           {}

// UnsafeCostSourceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CostSourceServiceServer will
// result in compilation errors.
type UnsafeCostSourceServiceServer interface {
	mustEmbedUnimplementedCostSourceServiceServer()
}

func RegisterCostSourceServiceServer(s grpc.ServiceRegistrar, srv CostSourceServiceServer) {
	// If the following call panics, it indicates UnimplementedCostSourceServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CostSourceService_ServiceDesc, srv)
}

func _CostSourceService_Name_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CostSourceServiceServer).Name(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CostSourceService_Name_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CostSourceServiceServer).Name(ctx, req.(*NameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CostSourceService_Supports_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SupportsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CostSourceServiceServer).Supports(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CostSourceService_Supports_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CostSourceServiceServer).Supports(ctx, req.(*SupportsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CostSourceService_GetActualCost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActualCostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CostSourceServiceServer).GetActualCost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CostSourceService_GetActualCost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CostSourceServiceServer).GetActualCost(ctx, req.(*GetActualCostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CostSourceService_GetProjectedCost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProjectedCostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CostSourceServiceServer).GetProjectedCost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CostSourceService_GetProjectedCost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CostSourceServiceServer).GetProjectedCost(ctx, req.(*GetProjectedCostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CostSourceService_GetPricingSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPricingSpecRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CostSourceServiceServer).GetPricingSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CostSourceService_GetPricingSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CostSourceServiceServer).GetPricingSpec(ctx, req.(*GetPricingSpecRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CostSourceService_EstimateCost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstimateCostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CostSourceServiceServer).EstimateCost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CostSourceService_EstimateCost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CostSourceServiceServer).EstimateCost(ctx, req.(*EstimateCostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CostSourceService_GetRecommendations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRecommendationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CostSourceServiceServer).GetRecommendations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CostSourceService_GetRecommendations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CostSourceServiceServer).GetRecommendations(ctx, req.(*GetRecommendationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CostSourceService_DismissRecommendation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DismissRecommendationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CostSourceServiceServer).DismissRecommendation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CostSourceService_DismissRecommendation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CostSourceServiceServer).DismissRecommendation(ctx, req.(*DismissRecommendationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CostSourceService_GetBudgets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBudgetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CostSourceServiceServer).GetBudgets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CostSourceService_GetBudgets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CostSourceServiceServer).GetBudgets(ctx, req.(*GetBudgetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CostSourceService_GetPluginInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPluginInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CostSourceServiceServer).GetPluginInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CostSourceService_GetPluginInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CostSourceServiceServer).GetPluginInfo(ctx, req.(*GetPluginInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CostSourceService_DryRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DryRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CostSourceServiceServer).DryRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CostSourceService_DryRun_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CostSourceServiceServer).DryRun(ctx, req.(*DryRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CostSourceService_ServiceDesc is the grpc.ServiceDesc for CostSourceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CostSourceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "finfocus.v1.CostSourceService",
	HandlerType: (*CostSourceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Name",
			Handler:    _CostSourceService_Name_Handler,
		},
		{
			MethodName: "Supports",
			Handler:    _CostSourceService_Supports_Handler,
		},
		{
			MethodName: "GetActualCost",
			Handler:    _CostSourceService_GetActualCost_Handler,
		},
		{
			MethodName: "GetProjectedCost",
			Handler:    _CostSourceService_GetProjectedCost_Handler,
		},
		{
			MethodName: "GetPricingSpec",
			Handler:    _CostSourceService_GetPricingSpec_Handler,
		},
		{
			MethodName: "EstimateCost",
			Handler:    _CostSourceService_EstimateCost_Handler,
		},
		{
			MethodName: "GetRecommendations",
			Handler:    _CostSourceService_GetRecommendations_Handler,
		},
		{
			MethodName: "DismissRecommendation",
			Handler:    _CostSourceService_DismissRecommendation_Handler,
		},
		{
			MethodName: "GetBudgets",
			Handler:    _CostSourceService_GetBudgets_Handler,
		},
		{
			MethodName: "GetPluginInfo",
			Handler:    _CostSourceService_GetPluginInfo_Handler,
		},
		{
			MethodName: "DryRun",
			Handler:    _CostSourceService_DryRun_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finfocus/v1/costsource.proto",
}

const (
	ObservabilityService_HealthCheck_FullMethodName               = "/finfocus.v1.ObservabilityService/HealthCheck"
	ObservabilityService_GetMetrics_FullMethodName                = "/finfocus.v1.ObservabilityService/GetMetrics"
	ObservabilityService_GetServiceLevelIndicators_FullMethodName = "/finfocus.v1.ObservabilityService/GetServiceLevelIndicators"
)

// ObservabilityServiceClient is the client API for ObservabilityService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ObservabilityService provides telemetry, health checks, and monitoring capabilities
// for cost source plugins. This service enables monitoring, debugging, and performance
// optimization of plugin implementations.
type ObservabilityServiceClient interface {
	// HealthCheck returns the current health status of the plugin.
	HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	// GetMetrics returns current metrics for monitoring plugin performance.
	GetMetrics(ctx context.Context, in *GetMetricsRequest, opts ...grpc.CallOption) (*GetMetricsResponse, error)
	// GetServiceLevelIndicators returns current SLI measurements.
	GetServiceLevelIndicators(ctx context.Context, in *GetServiceLevelIndicatorsRequest, opts ...grpc.CallOption) (*GetServiceLevelIndicatorsResponse, error)
}

type observabilityServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewObservabilityServiceClient(cc grpc.ClientConnInterface) ObservabilityServiceClient {
	return &observabilityServiceClient{cc}
}

func (c *observabilityServiceClient) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, ObservabilityService_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *observabilityServiceClient) GetMetrics(ctx context.Context, in *GetMetricsRequest, opts ...grpc.CallOption) (*GetMetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMetricsResponse)
	err := c.cc.Invoke(ctx, ObservabilityService_GetMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *observabilityServiceClient) GetServiceLevelIndicators(ctx context.Context, in *GetServiceLevelIndicatorsRequest, opts ...grpc.CallOption) (*GetServiceLevelIndicatorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetServiceLevelIndicatorsResponse)
	err := c.cc.Invoke(ctx, ObservabilityService_GetServiceLevelIndicators_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ObservabilityServiceServer is the server API for ObservabilityService service.
// All implementations must embed UnimplementedObservabilityServiceServer
// for forward compatibility.
//
// ObservabilityService provides telemetry, health checks, and monitoring capabilities
// for cost source plugins. This service enables monitoring, debugging, and performance
// optimization of plugin implementations.
type ObservabilityServiceServer interface {
	// HealthCheck returns the current health status of the plugin.
	HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	// GetMetrics returns current metrics for monitoring plugin performance.
	GetMetrics(context.Context, *GetMetricsRequest) (*GetMetricsResponse, error)
	// GetServiceLevelIndicators returns current SLI measurements.
	GetServiceLevelIndicators(context.Context, *GetServiceLevelIndicatorsRequest) (*GetServiceLevelIndicatorsResponse, error)
	mustEmbedUnimplementedObservabilityServiceServer()
}

// UnimplementedObservabilityServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedObservabilityServiceServer struct{}

func (UnimplementedObservabilityServiceServer) HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedObservabilityServiceServer) GetMetrics(context.Context, *GetMetricsRequest) (*GetMetricsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMetrics not implemented")
}
func (UnimplementedObservabilityServiceServer) GetServiceLevelIndicators(context.Context, *GetServiceLevelIndicatorsRequest) (*GetServiceLevelIndicatorsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetServiceLevelIndicators not implemented")
}
func (UnimplementedObservabilityServiceServer) mustEmbedUnimplementedObservabilityServiceServer() {}
func (UnimplementedObservabilityServiceServer) testEmbeddedByValue()                              {}

// UnsafeObservabilityServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ObservabilityServiceServer will
// result in compilation errors.
type UnsafeObservabilityServiceServer interface {
	mustEmbedUnimplementedObservabilityServiceServer()
}

func RegisterObservabilityServiceServer(s grpc.ServiceRegistrar, srv ObservabilityServiceServer) {
	// If the following call panics, it indicates UnimplementedObservabilityServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ObservabilityService_ServiceDesc, srv)
}

func _ObservabilityService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObservabilityServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ObservabilityService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObservabilityServiceServer).HealthCheck(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObservabilityService_GetMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObservabilityServiceServer).GetMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ObservabilityService_GetMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObservabilityServiceServer).GetMetrics(ctx, req.(*GetMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObservabilityService_GetServiceLevelIndicators_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServiceLevelIndicatorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObservabilityServiceServer).GetServiceLevelIndicators(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ObservabilityService_GetServiceLevelIndicators_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObservabilityServiceServer).GetServiceLevelIndicators(ctx, req.(*GetServiceLevelIndicatorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ObservabilityService_ServiceDesc is the grpc.ServiceDesc for ObservabilityService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ObservabilityService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "finfocus.v1.ObservabilityService",
	HandlerType: (*ObservabilityServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HealthCheck",
			Handler:    _ObservabilityService_HealthCheck_Handler,
		},
		{
			MethodName: "GetMetrics",
			Handler:    _ObservabilityService_GetMetrics_Handler,
		},
		{
			MethodName: "GetServiceLevelIndicators",
			Handler:    _ObservabilityService_GetServiceLevelIndicators_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finfocus/v1/costsource.proto",
}
